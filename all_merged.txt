Ruta al script: lib/configuracion/app_settings.dart
Nombre del script: app_settings.dart
Contenido del script:
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:the_good_alarm/services/vibration_service.dart';
import '../utils/constants.dart';

enum TimeFormat { h12, h24 }
enum InputFormat { numpad, circular }

class AppSettings with ChangeNotifier {
  late SharedPreferences _prefs;
  TimeFormat _timeFormat = TimeFormat.h24;
  InputFormat _inputFormat = InputFormat.circular;
  double _alarmVolume = 1.0;
  bool _vibrationEnabled = true;
  
  // Getters
  TimeFormat get timeFormat => _timeFormat;
  InputFormat get inputFormat => _inputFormat;
  double get alarmVolume => _alarmVolume;
  bool get vibrationEnabled => _vibrationEnabled;
  late VibrationService _vibrationService;

  AppSettings() {
    _loadSettings();
    _initializeVibration();
  }

  Future<void> _initializeVibration() async {
    _vibrationService = VibrationService();
    await _vibrationService.initialize();
    notifyListeners();
  }

  // Getter para el servicio de vibración
  VibrationService get vibrationService => _vibrationService;

  
  Future<void> _loadSettings() async {
    _prefs = await SharedPreferences.getInstance();
    
    // Cargar formato de hora
    final String? timeFormatString = _prefs.getString(AppConstants.keyTimeFormat);
    if (timeFormatString != null) {
      _timeFormat = TimeFormat.values.firstWhere(
        (e) => e.toString() == timeFormatString,
        orElse: () => TimeFormat.h24,
      );
    }
    
    // Cargar formato de entrada
    _inputFormat = _prefs.getBool(AppConstants.keyUseNumpad) == true
        ? InputFormat.numpad
        : InputFormat.circular;
    
    // Cargar volumen
    _alarmVolume = _prefs.getDouble(AppConstants.keyAlarmVolume) ?? 1.0;
    
    // Cargar vibración
    _vibrationEnabled = _prefs.getBool(AppConstants.keyVibrationEnabled) ?? true;
    
    notifyListeners();
  }
  
  Future<void> setTimeFormat(TimeFormat format) async {
    _timeFormat = format;
    await _prefs.setString(AppConstants.keyTimeFormat, format.toString());
    notifyListeners();
  }
  
  Future<void> setInputFormat(InputFormat format) async {
    _inputFormat = format;
    await _prefs.setBool(
      AppConstants.keyUseNumpad,
      format == InputFormat.numpad,
    );
    notifyListeners();
  }
  
  Future<void> setAlarmVolume(double volume) async {
    _alarmVolume = volume;
    await _prefs.setDouble(AppConstants.keyAlarmVolume, volume);
    notifyListeners();
  }
  
  Future<void> setVibrationEnabled(bool enabled) async {
    _vibrationEnabled = enabled;
    await _prefs.setBool(AppConstants.keyVibrationEnabled, enabled);
    notifyListeners();
  }
}

--------------------------------------------------

Ruta al script: lib/configuracion/theme_provider.dart
Nombre del script: theme_provider.dart
Contenido del script:
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';
import '../utils/constants.dart';

class ThemeProvider with ChangeNotifier {
  ThemeMode _themeMode = ThemeMode.system;
  late SharedPreferences _prefs;
  
  ThemeProvider() {
    _loadPreferences();
  }
  
  ThemeMode get themeMode => _themeMode;
  
  Future<void> _loadPreferences() async {
    _prefs = await SharedPreferences.getInstance();
    final String? themeModeString = _prefs.getString(AppConstants.keyThemeMode);
    if (themeModeString != null) {
      _themeMode = ThemeMode.values.firstWhere(
        (e) => e.toString() == themeModeString,
        orElse: () => ThemeMode.system,
      );
      notifyListeners();
    }
  }
  
  Future<void> setThemeMode(ThemeMode mode) async {
    _themeMode = mode;
    await _prefs.setString(AppConstants.keyThemeMode, mode.toString());
    notifyListeners();
  }
  
  ThemeData getLightTheme() {
    return ThemeData(
      useMaterial3: true,
      colorScheme: const ColorScheme.light(
        primary: AppConstants.primaryLightColor,
        secondary: AppConstants.accentLightColor,
      ),
      // Personaliza más aspectos del tema aquí
    );
  }
  
  ThemeData getDarkTheme() {
    return ThemeData(
      useMaterial3: true,
      colorScheme: const ColorScheme.dark(
        primary: AppConstants.primaryDarkColor,
        secondary: AppConstants.accentDarkColor,
      ),
      // Personaliza más aspectos del tema aquí
    );
  }
}

--------------------------------------------------

Ruta al script: lib/models/alarm_history_entry.dart
Nombre del script: alarm_history_entry.dart
Contenido del script:
enum AlarmEventType {
  created,      // Alarma creada
  activated,    // Alarma activada
  deactivated,  // Alarma desactivada
  triggered,    // Alarma sonó
  snoozed,      // Alarma pospuesta
  stopped,      // Alarma detenida
  dismissed,    // Alarma omitida
}

class AlarmHistoryEntry {
  final String alarmId;
  final DateTime timestamp;
  final AlarmEventType eventType;
  final Map<String, dynamic> metadata;

  AlarmHistoryEntry({
    required this.alarmId,
    required this.timestamp,
    required this.eventType,
    this.metadata = const {},
  });

  Map<String, dynamic> toJson() {
    return {
      'alarmId': alarmId,
      'timestamp': timestamp.toIso8601String(),
      'eventType': eventType.toString(),
      'metadata': metadata,
    };
  }

  factory AlarmHistoryEntry.fromJson(Map<String, dynamic> json) {
    return AlarmHistoryEntry(
      alarmId: json['alarmId'],
      timestamp: DateTime.parse(json['timestamp']),
      eventType: AlarmEventType.values.firstWhere(
        (e) => e.toString() == json['eventType'],
      ),
      metadata: Map<String, dynamic>.from(json['metadata'] ?? {}),
    );
  }
}



--------------------------------------------------

Ruta al script: lib/models/alarm.dart
Nombre del script: alarm.dart
Contenido del script:
import 'dart:convert';

class Alarm {
  final String id;
  String name;
  DateTime time;
  bool isEnabled;
  List<bool> weekDays; // [lun, mar, mie, jue, vie, sab, dom]
  bool isOneTime;
  int snoozeTime; // en minutos
  int snoozeCount;
  int maxSnoozeCount;
  String? selectedGame; // 'math' o 'memory'
  String? gameDifficulty; // 'easy', 'medium', 'hard'
  bool requireGame;
  final bool useVibration;
  int totalTimesTriggered;
  int totalTimesStopped;
  int totalTimesSnoozed;
  
  Alarm({
    required this.id,
    this.name = '',
    required this.time,
    this.isEnabled = true,
    List<bool>? weekDays,
    this.isOneTime = false,
    this.snoozeTime = 5,
    this.snoozeCount = 0,
    this.maxSnoozeCount = 3,
    this.selectedGame,
    this.gameDifficulty,
    this.requireGame = false,
    this.useVibration = true,
    this.totalTimesTriggered = 0,
    this.totalTimesStopped = 0,
    this.totalTimesSnoozed = 0,
  }) : weekDays = weekDays ?? List.filled(7, false);

  // Copia del objeto con posibles modificaciones
  Alarm copyWith({
    String? name,
    DateTime? time,
    bool? isEnabled,
    List<bool>? weekDays,
    bool? isOneTime,
    int? snoozeTime,
    int? snoozeCount,
    int? maxSnoozeCount,
    String? selectedGame,
    String? gameDifficulty,
    bool? requireGame,
    bool? useVibration,
  }) {
    return Alarm(
      id: id,
      name: name ?? this.name,
      time: time ?? this.time,
      isEnabled: isEnabled ?? this.isEnabled,
      weekDays: weekDays ?? List.from(this.weekDays),
      isOneTime: isOneTime ?? this.isOneTime,
      snoozeTime: snoozeTime ?? this.snoozeTime,
      snoozeCount: snoozeCount ?? this.snoozeCount,
      maxSnoozeCount: maxSnoozeCount ?? this.maxSnoozeCount,
      selectedGame: selectedGame ?? this.selectedGame,
      gameDifficulty: gameDifficulty ?? this.gameDifficulty,
      requireGame: requireGame ?? this.requireGame,
      useVibration: useVibration ?? this.useVibration,
    );
  }

  // Convertir a Map para almacenamiento
  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'time': time.toIso8601String(),
      'isEnabled': isEnabled,
      'weekDays': weekDays,
      'isOneTime': isOneTime,
      'snoozeTime': snoozeTime,
      'snoozeCount': snoozeCount,
      'maxSnoozeCount': maxSnoozeCount,
      'selectedGame': selectedGame,
      'gameDifficulty': gameDifficulty,
      'requireGame': requireGame,
      'useVibration': useVibration,
      'totalTimesTriggered': totalTimesTriggered,
      'totalTimesStopped': totalTimesStopped,
      'totalTimesSnoozed': totalTimesSnoozed,
    };
  }

  // Crear objeto desde Map
  factory Alarm.fromJson(Map<String, dynamic> json) {
    return Alarm(
      id: json['id'],
      name: json['name'],
      time: DateTime.parse(json['time']),
      isEnabled: json['isEnabled'],
      weekDays: List<bool>.from(json['weekDays']),
      isOneTime: json['isOneTime'],
      snoozeTime: json['snoozeTime'],
      snoozeCount: json['snoozeCount'],
      maxSnoozeCount: json['maxSnoozeCount'],
      selectedGame: json['selectedGame'],
      gameDifficulty: json['gameDifficulty'],
      requireGame: json['requireGame'],
      useVibration: json['useVibration'] ?? true,
      totalTimesTriggered: json['totalTimesTriggered'] ?? 0,
      totalTimesStopped: json['totalTimesStopped'] ?? 0,
      totalTimesSnoozed: json['totalTimesSnoozed'] ?? 0,
    );
  }

  // Convertir a String para almacenamiento
  String toJsonString() => jsonEncode(toJson());

  // Crear objeto desde String
  factory Alarm.fromJsonString(String jsonString) {
    return Alarm.fromJson(jsonDecode(jsonString));
  }

  // Obtener próxima fecha de alarma
  DateTime getNextAlarmTime() {
    if (isOneTime) {
      return time.isBefore(DateTime.now()) ? time.add(const Duration(days: 1)) : time;
    }

    DateTime now = DateTime.now();
    DateTime candidate = DateTime(
      now.year,
      now.month,
      now.day,
      time.hour,
      time.minute,
    );

    // Si la hora ya pasó hoy, empezar a buscar desde mañana
    if (candidate.isBefore(now)) {
      candidate = candidate.add(const Duration(days: 1));
    }

    // Buscar el próximo día activo
    for (int i = 0; i < 7; i++) {
      int weekday = candidate.weekday - 1; // 0 = Lunes, 6 = Domingo
      if (weekDays[weekday]) {
        return candidate;
      }
      candidate = candidate.add(const Duration(days: 1));
    }

    // Si no hay días activos, retornar null o lanzar una excepción
    throw Exception('No active days set for alarm');
  }

  // Verificar si la alarma debe sonar en un día específico
  bool shouldRingOn(DateTime date) {
    if (isOneTime) {
      return date.year == time.year &&
             date.month == time.month &&
             date.day == time.day;
    }
    return weekDays[date.weekday - 1];
  }

  // Activar/desactivar la alarma
  void toggleEnabled() {
    isEnabled = !isEnabled;
  }

  // Registrar un snooze
  bool canSnooze() {
    return snoozeCount < maxSnoozeCount;
  }

  void incrementSnoozeCount() {
    if (canSnooze()) {
      snoozeCount++;
    }
  }

  void resetSnoozeCount() {
    snoozeCount = 0;
  }

  // Obtener tiempo hasta la próxima alarma en minutos
  int getTimeToAlarmInMinutes() {
    final nextAlarm = getNextAlarmTime();
    return nextAlarm.difference(DateTime.now()).inMinutes;
  }
}

--------------------------------------------------

Ruta al script: lib/models/game_settings.dart
Nombre del script: game_settings.dart
Contenido del script:
import 'dart:convert';
import '../utils/constants.dart';

enum GameType { math, memory }
enum GameDifficulty { easy, medium, hard }

class GameSettings {
  final GameType gameType;
  GameDifficulty difficulty;
  int problemCount;
  int timeLimit; // en segundos
  bool isTimeLimited;
  Map<String, dynamic> specificSettings;
  
  // Constructor
  GameSettings({
    required this.gameType,
    this.difficulty = GameDifficulty.easy,
    this.problemCount = 3,
    this.timeLimit = 60,
    this.isTimeLimited = false,
    Map<String, dynamic>? specificSettings,
  }) : specificSettings = specificSettings ?? _getDefaultSpecificSettings(gameType);

  // Configuraciones específicas por defecto según el tipo de juego
  static Map<String, dynamic> _getDefaultSpecificSettings(GameType type) {
    switch (type) {
      case GameType.math:
        return {
          'operationTypes': ['addition', 'subtraction'], // multiplication, division
          'maxNumber': 10,
          'allowNegatives': false,
          'requireWholeNumbers': true,
        };
      case GameType.memory:
        return {
          'useTriples': false,
          'showTimer': true,
          'cardTheme': 'numbers', // numbers, symbols, colors
          'matchTime': 1000, // tiempo en ms para mostrar las cartas al hacer match
        };
    }
  }

  // Obtener cantidad de problemas según dificultad
  int getProblemCount() {
    switch (gameType) {
      case GameType.math:
        switch (difficulty) {
          case GameDifficulty.easy:
            return AppConstants.mathGameEasyProblems;
          case GameDifficulty.medium:
            return AppConstants.mathGameMediumProblems;
          case GameDifficulty.hard:
            return AppConstants.mathGameHardProblems;
        }
      case GameType.memory:
        switch (difficulty) {
          case GameDifficulty.easy:
            return AppConstants.memoryGameEasyPairs;
          case GameDifficulty.medium:
            return AppConstants.memoryGameMediumPairs;
          case GameDifficulty.hard:
            return AppConstants.memoryGameHardPairs;
        }
    }
  }

  // Obtener tiempo límite según dificultad (en segundos)
  int getTimeLimit() {
    if (!isTimeLimited) return 0;
    
    switch (difficulty) {
      case GameDifficulty.easy:
        return 120; // 2 minutos
      case GameDifficulty.medium:
        return 90; // 1.5 minutos
      case GameDifficulty.hard:
        return 60; // 1 minuto
    }
  }

  // Métodos específicos para juego matemático
  int getMathMaxNumber() {
    if (gameType != GameType.math) return 0;
    
    switch (difficulty) {
      case GameDifficulty.easy:
        return 10;
      case GameDifficulty.medium:
        return 25;
      case GameDifficulty.hard:
        return 100;
    }
  }

  List<String> getMathOperations() {
    if (gameType != GameType.math) return [];
    
    switch (difficulty) {
      case GameDifficulty.easy:
        return ['addition', 'subtraction'];
      case GameDifficulty.medium:
        return ['addition', 'subtraction', 'multiplication'];
      case GameDifficulty.hard:
        return ['addition', 'subtraction', 'multiplication', 'division'];
    }
  }

  // Métodos específicos para juego de memoria
  int getMemoryPairCount() {
    if (gameType != GameType.memory) return 0;
    
    return getProblemCount();
  }

  bool useTriples() {
    if (gameType != GameType.memory) return false;
    return difficulty == GameDifficulty.hard && specificSettings['useTriples'] as bool;
  }

  // Serialización
  Map<String, dynamic> toJson() {
    return {
      'gameType': gameType.toString(),
      'difficulty': difficulty.toString(),
      'problemCount': problemCount,
      'timeLimit': timeLimit,
      'isTimeLimited': isTimeLimited,
      'specificSettings': specificSettings,
    };
  }

  // Deserialización
  factory GameSettings.fromJson(Map<String, dynamic> json) {
    return GameSettings(
      gameType: GameType.values.firstWhere(
        (e) => e.toString() == json['gameType'],
      ),
      difficulty: GameDifficulty.values.firstWhere(
        (e) => e.toString() == json['difficulty'],
      ),
      problemCount: json['problemCount'],
      timeLimit: json['timeLimit'],
      isTimeLimited: json['isTimeLimited'],
      specificSettings: Map<String, dynamic>.from(json['specificSettings']),
    );
  }

  // Convertir a String
  String toJsonString() => jsonEncode(toJson());

  // Crear desde String
  factory GameSettings.fromJsonString(String jsonString) {
    return GameSettings.fromJson(jsonDecode(jsonString));
  }

  // Copiar con modificaciones
  GameSettings copyWith({
    GameDifficulty? difficulty,
    int? problemCount,
    int? timeLimit,
    bool? isTimeLimited,
    Map<String, dynamic>? specificSettings,
  }) {
    return GameSettings(
      gameType: gameType,
      difficulty: difficulty ?? this.difficulty,
      problemCount: problemCount ?? this.problemCount,
      timeLimit: timeLimit ?? this.timeLimit,
      isTimeLimited: isTimeLimited ?? this.isTimeLimited,
      specificSettings: specificSettings ?? Map.from(this.specificSettings),
    );
  }

  // Validar configuración
  bool isValid() {
    if (problemCount <= 0) return false;
    if (isTimeLimited && timeLimit <= 0) return false;
    
    switch (gameType) {
      case GameType.math:
        return specificSettings.containsKey('operationTypes') &&
               (specificSettings['operationTypes'] as List).isNotEmpty &&
               specificSettings.containsKey('maxNumber') &&
               (specificSettings['maxNumber'] as int) > 0;
      
      case GameType.memory:
        return specificSettings.containsKey('cardTheme') &&
               specificSettings.containsKey('matchTime') &&
               (specificSettings['matchTime'] as int) > 0;
    }
  }

  // Crear configuración predeterminada para un tipo de juego
  factory GameSettings.createDefault(GameType type) {
    return GameSettings(
      gameType: type,
      difficulty: GameDifficulty.easy,
      specificSettings: _getDefaultSpecificSettings(type),
    );
  }
}

--------------------------------------------------

Ruta al script: lib/models/time_interval_settings.dart
Nombre del script: time_interval_settings.dart
Contenido del script:
import 'package:flutter/material.dart';
import 'package:shared_preferences/shared_preferences.dart';

class TimeIntervalSettings {
  late TimeOfDay morningStart;
  late TimeOfDay morningEnd;
  late TimeOfDay afternoonStart;
  late TimeOfDay afternoonEnd;
  late TimeOfDay nightStart;
  late TimeOfDay nightEnd;

  TimeIntervalSettings({
    TimeOfDay? morningStart,
    TimeOfDay? morningEnd,
    TimeOfDay? afternoonStart,
    TimeOfDay? afternoonEnd,
    TimeOfDay? nightStart,
    TimeOfDay? nightEnd,
  }) {
    this.morningStart = morningStart ?? const TimeOfDay(hour: 5, minute: 0);
    this.morningEnd = morningEnd ?? const TimeOfDay(hour: 11, minute: 59);
    this.afternoonStart = afternoonStart ?? const TimeOfDay(hour: 12, minute: 0);
    this.afternoonEnd = afternoonEnd ?? const TimeOfDay(hour: 20, minute: 59);
    this.nightStart = nightStart ?? const TimeOfDay(hour: 21, minute: 0);
    this.nightEnd = nightEnd ?? const TimeOfDay(hour: 4, minute: 59);
  }

  Future<void> save() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt('morningStartHour', morningStart.hour);
    await prefs.setInt('morningStartMinute', morningStart.minute);
    await prefs.setInt('morningEndHour', morningEnd.hour);
    await prefs.setInt('morningEndMinute', morningEnd.minute);
    await prefs.setInt('afternoonStartHour', afternoonStart.hour);
    await prefs.setInt('afternoonStartMinute', afternoonStart.minute);
    await prefs.setInt('afternoonEndHour', afternoonEnd.hour);
    await prefs.setInt('afternoonEndMinute', afternoonEnd.minute);
    await prefs.setInt('nightStartHour', nightStart.hour);
    await prefs.setInt('nightStartMinute', nightStart.minute);
    await prefs.setInt('nightEndHour', nightEnd.hour);
    await prefs.setInt('nightEndMinute', nightEnd.minute);
  }

  static Future<TimeIntervalSettings> load() async {
    final prefs = await SharedPreferences.getInstance();
    return TimeIntervalSettings(
      morningStart: TimeOfDay(
        hour: prefs.getInt('morningStartHour') ?? 5,
        minute: prefs.getInt('morningStartMinute') ?? 0,
      ),
      morningEnd: TimeOfDay(
        hour: prefs.getInt('morningEndHour') ?? 11,
        minute: prefs.getInt('morningEndMinute') ?? 59,
      ),
      afternoonStart: TimeOfDay(
        hour: prefs.getInt('afternoonStartHour') ?? 12,
        minute: prefs.getInt('afternoonStartMinute') ?? 0,
      ),
      afternoonEnd: TimeOfDay(
        hour: prefs.getInt('afternoonEndHour') ?? 20,
        minute: prefs.getInt('afternoonEndMinute') ?? 59,
      ),
      nightStart: TimeOfDay(
        hour: prefs.getInt('nightStartHour') ?? 21,
        minute: prefs.getInt('nightStartMinute') ?? 0,
      ),
      nightEnd: TimeOfDay(
        hour: prefs.getInt('nightEndHour') ?? 4,
        minute: prefs.getInt('nightEndMinute') ?? 59,
      ),
    );
  }

  bool isValidConfiguration() {
    // Mejorar la validación para manejar intervalos que cruzan la media noche
    return _validateInterval(morningStart, morningEnd) &&
           _validateInterval(afternoonStart, afternoonEnd) &&
           _validateInterval(nightStart, nightEnd) &&
           !_intervalsOverlap();
  }

  bool _validateInterval(TimeOfDay start, TimeOfDay end) {
    // Convertir a minutos desde media noche
    int startMinutes = start.hour * 60 + start.minute;
    int endMinutes = end.hour * 60 + end.minute;

    // Manejar caso de intervalo que cruza la media noche
    if (endMinutes < startMinutes) {
      endMinutes += 24 * 60;
    }

    return startMinutes < endMinutes;
  }

  bool _intervalsOverlap() {
    // Convertir todos los intervalos a minutos desde media noche
    List<int> morningMinutes = _intervalToMinutes(morningStart, morningEnd);
    List<int> afternoonMinutes = _intervalToMinutes(afternoonStart, afternoonEnd);
    List<int> nightMinutes = _intervalToMinutes(nightStart, nightEnd);

    // Verificar si hay intersecciones
    return _hasOverlap(morningMinutes, afternoonMinutes) ||
           _hasOverlap(morningMinutes, nightMinutes) ||
           _hasOverlap(afternoonMinutes, nightMinutes);
  }

  List<int> _intervalToMinutes(TimeOfDay start, TimeOfDay end) {
    int startMinutes = start.hour * 60 + start.minute;
    int endMinutes = end.hour * 60 + end.minute;

    // Manejar caso de intervalo que cruza la media noche
    if (endMinutes < startMinutes) {
      endMinutes += 24 * 60;
    }

    return [startMinutes, endMinutes];
  }

  bool _hasOverlap(List<int> interval1, List<int> interval2) {
    return !(interval1[1] < interval2[0] || interval2[1] < interval1[0]);
  }

  // Método para convertir TimeOfDay a minutos desde media noche
  int _timeOfDayToMinutes(TimeOfDay time) {
    return time.hour * 60 + time.minute;
  }

  // Método para convertir minutos a TimeOfDay
  TimeOfDay _minutesToTimeOfDay(int minutes) {
    int adjustedMinutes = minutes % (24 * 60);
    return TimeOfDay(
      hour: adjustedMinutes ~/ 60,
      minute: adjustedMinutes % 60,
    );
  }

  // Método para ajustar un intervalo de tiempo
  TimeIntervalSettings adjustInterval({
    TimeOfDay? morningStart,
    TimeOfDay? morningEnd,
    TimeOfDay? afternoonStart,
    TimeOfDay? afternoonEnd,
    TimeOfDay? nightStart,
    TimeOfDay? nightEnd,
  }) {
    return TimeIntervalSettings(
      morningStart: morningStart ?? this.morningStart,
      morningEnd: morningEnd ?? this.morningEnd,
      afternoonStart: afternoonStart ?? this.afternoonStart,
      afternoonEnd: afternoonEnd ?? this.afternoonEnd,
      nightStart: nightStart ?? this.nightStart,
      nightEnd: nightEnd ?? this.nightEnd,
    );
  }

  // Método para dividir un intervalo de tiempo en segmentos
  List<TimeOfDay> splitInterval(TimeOfDay start, TimeOfDay end, int segments) {
    int startMinutes = _timeOfDayToMinutes(start);
    int endMinutes = _timeOfDayToMinutes(end);

    // Manejar caso de intervalo que cruza la media noche
    if (endMinutes < startMinutes) {
      endMinutes += 24 * 60;
    }

    int intervalMinutes = endMinutes - startMinutes;
    int segmentSize = intervalMinutes ~/ segments;

    return List.generate(segments + 1, (index) {
      int currentMinutes = startMinutes + (index * segmentSize);
      return _minutesToTimeOfDay(currentMinutes);
    });
  }

  // Método para encontrar el intervalo al que pertenece un TimeOfDay
  String getIntervalName(TimeOfDay time) {
    int minutes = _timeOfDayToMinutes(time);

    if (_isTimeInInterval(time, morningStart, morningEnd)) {
      return 'morning';
    } else if (_isTimeInInterval(time, afternoonStart, afternoonEnd)) {
      return 'afternoon';
    } else if (_isTimeInInterval(time, nightStart, nightEnd)) {
      return 'night';
    }

    return 'unknown';
  }

  // Método auxiliar para verificar si un tiempo está en un intervalo
  bool _isTimeInInterval(TimeOfDay time, TimeOfDay start, TimeOfDay end) {
    int timeMinutes = _timeOfDayToMinutes(time);
    int startMinutes = _timeOfDayToMinutes(start);
    int endMinutes = _timeOfDayToMinutes(end);

    // Manejar caso de intervalo que cruza la media noche
    if (endMinutes < startMinutes) {
      return timeMinutes >= startMinutes || timeMinutes <= endMinutes;
    }

    return timeMinutes >= startMinutes && timeMinutes <= endMinutes;
  }
}


--------------------------------------------------

Ruta al script: lib/services/alarm_history_service.dart
Nombre del script: alarm_history_service.dart
Contenido del script:
import 'dart:convert';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:the_good_alarm/models/alarm_history_entry.dart';

class AlarmHistoryService {
  static final AlarmHistoryService _instance = AlarmHistoryService._internal();
  factory AlarmHistoryService() => _instance;
  AlarmHistoryService._internal();

  static const String _storageKey = 'alarm_history_entries';
  late SharedPreferences _prefs;
  List<AlarmHistoryEntry> _historyEntries = [];

  Future<void> initialize() async {
    _prefs = await SharedPreferences.getInstance();
    await _loadHistoryEntries();
  }

  Future<void> _loadHistoryEntries() async {
    final String? entriesJson = _prefs.getString(_storageKey);
    if (entriesJson != null) {
      final List<dynamic> entriesList = jsonDecode(entriesJson);
      _historyEntries = entriesList
          .map((json) => AlarmHistoryEntry.fromJson(json))
          .toList();
    }
  }

  Future<void> _saveHistoryEntries() async {
    final String entriesJson = jsonEncode(
      _historyEntries.map((entry) => entry.toJson()).toList(),
    );
    await _prefs.setString(_storageKey, entriesJson);
  }

  Future<void> addHistoryEntry(AlarmHistoryEntry entry) async {
    _historyEntries.add(entry);
    
    // Mantener solo los últimos 100 registros
    if (_historyEntries.length > 100) {
      _historyEntries.removeRange(0, _historyEntries.length - 100);
    }

    await _saveHistoryEntries();
  }

  List<AlarmHistoryEntry> getHistoryForAlarm(String alarmId) {
    return _historyEntries
        .where((entry) => entry.alarmId == alarmId)
        .toList()
      ..sort((a, b) => b.timestamp.compareTo(a.timestamp));
  }

  List<AlarmHistoryEntry> getAllHistory() {
    return List.from(_historyEntries)
      ..sort((a, b) => b.timestamp.compareTo(a.timestamp));
  }
}

--------------------------------------------------

Ruta al script: lib/utils/constants.dart
Nombre del script: constants.dart
Contenido del script:
import 'package:flutter/material.dart';

class AppConstants {
  // Temas
  static const Color primaryLightColor = Color(0xFF2196F3);
  static const Color primaryDarkColor = Color(0xFF1976D2);
  static const Color accentLightColor = Color(0xFF03A9F4);
  static const Color accentDarkColor = Color(0xFF0288D1);
  
  // Configuraciones de juego
  static const int mathGameEasyProblems = 3;
  static const int mathGameMediumProblems = 5;
  static const int mathGameHardProblems = 7;
  
  static const int memoryGameEasyPairs = 6;
  static const int memoryGameMediumPairs = 12;
  static const int memoryGameHardPairs = 18;
  
  // Configuraciones de alarma
  static const int defaultSnoozeTime = 5; // minutos
  static const int maxSnoozeCount = 3;
  
  // Keys para SharedPreferences
  static const String keyThemeMode = 'theme_mode';
  static const String keyTimeFormat = 'time_format';
  static const String keyUseNumpad = 'use_numpad';
  static const String keyAlarmVolume = 'alarm_volume';
  static const String keyVibrationEnabled = 'vibration_enabled';
}

--------------------------------------------------

Ruta al script: lib/services/alarm_service.dart
Nombre del script: alarm_service.dart
Contenido del script:
import 'dart:async';
import 'dart:convert';
import 'package:flutter/foundation.dart';
import 'package:shared_preferences/shared_preferences.dart';
import 'package:the_good_alarm/models/alarm_history_entry.dart';
import '../models/alarm.dart';
import 'notification_service.dart';
import 'package:the_good_alarm/services/alarm_history_service.dart';

class AlarmService {
  static final AlarmService _instance = AlarmService._internal();
  factory AlarmService() => _instance;
  AlarmService._internal() {
    _initializeStream();
  }

  static const String _storageKey = 'alarms';
  final NotificationService _notificationService = NotificationService();
  late SharedPreferences _prefs;
  List<Alarm> _alarms = [];

  // Usar un BehaviorSubject para mantener el último estado
  late StreamController<List<Alarm>> _alarmsController =
      StreamController<List<Alarm>>.broadcast();
  Stream<List<Alarm>> get alarmsStream => _alarmsController.stream;

  // Stream específico para alarmas activas
  Stream<List<Alarm>> get activeAlarmsStream => alarmsStream
      .map((allAlarms) => allAlarms.where((alarm) => alarm.isEnabled).toList());

  // Getter para la lista de alarmas
  List<Alarm> get alarms => List.unmodifiable(_alarms);

  // Getter para alarmas activas
  List<Alarm> get activeAlarms =>
      _alarms.where((alarm) => alarm.isEnabled).toList();

  final AlarmHistoryService _alarmHistoryService = AlarmHistoryService();

  Future<void> initialize() async {
    try {
      _prefs = await SharedPreferences.getInstance();
      await _loadAlarms();
    } catch (e) {
      debugPrint('Error inicializando AlarmService: $e');
      _notifyListeners(); // Notificar incluso en caso de error
    }
  }

  void _initializeStream() {
    if (_alarmsController.isClosed) {
      _alarmsController = StreamController<List<Alarm>>.broadcast();
    }
  }

  void _notifyListeners() {
    if (!_alarmsController.isClosed) {
      _alarmsController.add(List.unmodifiable(_alarms));
    }
  }

  Future<void> _loadAlarms() async {
    try {
      final String? alarmsJson = _prefs.getString(_storageKey);
      if (alarmsJson != null) {
        final List<dynamic> alarmsList = jsonDecode(alarmsJson);
        _alarms = alarmsList.map((json) => Alarm.fromJson(json)).toList();

        // Reprogramar alarmas activas
        for (final alarm in _alarms) {
          if (alarm.isEnabled) {
            await _notificationService.scheduleAlarm(alarm);
          }
        }
      } else {
        _alarms = [];
      }

      _notifyListeners();
    } catch (e) {
      debugPrint('Error al cargar alarmas: $e');
      _alarms = [];
      _notifyListeners();
    }
  }

  Future<void> _saveAlarms() async {
    try {
      final String alarmsJson =
          jsonEncode(_alarms.map((a) => a.toJson()).toList());
      await _prefs.setString(_storageKey, alarmsJson);
      _notifyListeners();
    } catch (e) {
      debugPrint('Error al guardar alarmas: $e');
    }
  }

  Future<void> addAlarm(Alarm alarm) async {
    _alarms.add(alarm);
    // Registrar evento de creación
    await _alarmHistoryService.addHistoryEntry(
      AlarmHistoryEntry(
        alarmId: alarm.id,
        timestamp: DateTime.now(),
        eventType: AlarmEventType.created,
      ),
    );

    if (alarm.isEnabled) {
      await _notificationService.scheduleAlarm(alarm);
    }
    await _saveAlarms();
  }

  Future<void> updateAlarm(Alarm alarm) async {
    final index = _alarms.indexWhere((a) => a.id == alarm.id);
    if (index != -1) {
      await _notificationService.cancelAlarm(_alarms[index].id);
      _alarms[index] = alarm;
      if (alarm.isEnabled) {
        await _notificationService.scheduleAlarm(alarm);
      }
      await _saveAlarms();
    }
  }

  Future<void> deleteAlarm(String alarmId) async {
    await _notificationService.cancelAlarm(alarmId);
    _alarms.removeWhere((a) => a.id == alarmId);
    await _saveAlarms();
  }

  Future<void> toggleAlarm(String alarmId) async {
    final index = _alarms.indexWhere((a) => a.id == alarmId);
    if (index != -1) {
      _alarms[index] = _alarms[index].copyWith(
        isEnabled: !_alarms[index].isEnabled,
      );

      if (_alarms[index].isEnabled) {
        await _notificationService.scheduleAlarm(_alarms[index]);
      } else {
        await _notificationService.cancelAlarm(alarmId);
      }

      await _saveAlarms();
      _notifyListeners();
    }
  }

  Future<void> snoozeAlarm(String alarmId) async {
    final alarm = _alarms.firstWhere((a) => a.id == alarmId);
    if (alarm.canSnooze()) {
      alarm.incrementSnoozeCount();
      alarm.totalTimesSnoozed++;

      await _alarmHistoryService.addHistoryEntry(
        AlarmHistoryEntry(
          alarmId: alarmId,
          timestamp: DateTime.now(),
          eventType: AlarmEventType.snoozed,
          metadata: {
            'snoozeCount': alarm.snoozeCount,
          },
        ),
      );

      final DateTime newTime =
          DateTime.now().add(Duration(minutes: alarm.snoozeTime));
      await _notificationService.cancelAlarm(alarmId);
      await _notificationService.scheduleAlarm(alarm.copyWith(time: newTime));
      await _saveAlarms();
    }
  }

  Future<void> stopAlarm(String alarmId) async {
    final alarm = _alarms.firstWhere((a) => a.id == alarmId);
    await _notificationService.cancelAlarm(alarmId);
    alarm.resetSnoozeCount();
    if (!alarm.isOneTime) {
      await _notificationService.scheduleAlarm(alarm);
    }
    await _saveAlarms();
  }

  List<Alarm> getActiveAlarms() {
    return _alarms.where((alarm) => alarm.isEnabled).toList();
  }

  List<Alarm> getAlarmsForDay(DateTime date) {
    return _alarms
        .where((alarm) => alarm.isEnabled && alarm.shouldRingOn(date))
        .toList();
  }

  void dispose() {
    _alarmsController.close();
  }
}


--------------------------------------------------

Ruta al script: lib/services/background_service.dart
Nombre del script: background_service.dart
Contenido del script:
import 'dart:async';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import '../models/alarm.dart';
import 'notification_service.dart';
import 'alarm_service.dart';

@pragma('vm:entry-point')
void backgroundMain() {
  WidgetsFlutterBinding.ensureInitialized();
  DartPluginRegistrant.ensureInitialized();
  
  final service = FlutterBackgroundService();
  
  service.invoke('stopService');
}

class BackgroundService {
  static final BackgroundService _instance = BackgroundService._internal();
  factory BackgroundService() => _instance;
  BackgroundService._internal();

  final FlutterBackgroundService _service = FlutterBackgroundService();

  Future<void> initialize() async {
    await _service.configure(
      iosConfiguration: IosConfiguration(), // Requerido por el paquete
      androidConfiguration: AndroidConfiguration(
        onStart: onStart,
        autoStart: true,
        isForegroundMode: true,
        notificationChannelId: 'alarm_service',
        initialNotificationTitle: 'Servicio de Alarma',
        initialNotificationContent: 'Ejecutándose en segundo plano',
        foregroundServiceNotificationId: 888,
        autoStartOnBoot: true,
      ),
    );

    await _service.startService();
  }

  Future<bool> isRunning() async {
    return await _service.isRunning();
  }

  Future<void> updateAlarms() async {
    _service.invoke('updateAlarms');
  }

  Future<void> stopService() async {
    _service.invoke('stopService');
  }
}

@pragma('vm:entry-point')
void onStart(ServiceInstance service) async {
  DartPluginRegistrant.ensureInitialized();

  // Inicializar servicios necesarios
  final notificationService = NotificationService();
  final alarmService = AlarmService();
  await notificationService.initialize();
  await alarmService.initialize();

  // Verificar alarmas cada minuto
  Timer.periodic(const Duration(minutes: 1), (timer) async {
    if (service is AndroidServiceInstance) {
      if (await service.isForegroundService()) {
        // Actualizar notificación del servicio
        service.setForegroundNotificationInfo(
          title: 'Servicio de Alarma',
          content: 'Monitoreando alarmas - ${DateTime.now().toString()}',
        );
      }
    }

    _checkAlarms(alarmService, notificationService);
  });

  // Manejar eventos del servicio
  service.on('updateAlarms').listen((event) async {
    await alarmService.initialize();
  });

  service.on('stopService').listen((event) {
    service.stopSelf();
  });

  // Manejar reinicios del dispositivo
  service.on('onBoot').listen((event) async {
    await _handleDeviceBoot(alarmService, notificationService);
  });
}

Future<void> _checkAlarms(
  AlarmService alarmService,
  NotificationService notificationService,
) async {
  final now = DateTime.now();
  final activeAlarms = alarmService.getActiveAlarms();

  for (final alarm in activeAlarms) {
    if (_shouldTriggerAlarm(alarm, now)) {
      await _triggerAlarm(alarm, notificationService);
    }
  }
}

bool _shouldTriggerAlarm(Alarm alarm, DateTime now) {
  if (!alarm.isEnabled) return false;

  final nextAlarmTime = alarm.getNextAlarmTime();
  return nextAlarmTime.year == now.year &&
         nextAlarmTime.month == now.month &&
         nextAlarmTime.day == now.day &&
         nextAlarmTime.hour == now.hour &&
         nextAlarmTime.minute == now.minute;
}

Future<void> _triggerAlarm(
  Alarm alarm,
  NotificationService notificationService,
) async {
  // Mostrar pantalla completa y notificación
  await notificationService.showAlarmNotification(alarm);
}

Future<void> _handleDeviceBoot(
  AlarmService alarmService,
  NotificationService notificationService,
) async {
  // Reprogramar todas las alarmas activas después del reinicio
  final activeAlarms = alarmService.getActiveAlarms();
  for (final alarm in activeAlarms) {
    await notificationService.scheduleAlarm(alarm);
  }
}

--------------------------------------------------

Ruta al script: lib/services/notification_service.dart
Nombre del script: notification_service.dart
Contenido del script:
import 'dart:typed_data';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import '../models/alarm.dart';
import '../services/alarm_service.dart';
import 'package:flutter/services.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:timezone/data/latest.dart' as tz;

class NotificationService {
  static final NotificationService _instance = NotificationService._internal();
  factory NotificationService() => _instance;
  NotificationService._internal();

  final FlutterLocalNotificationsPlugin _notifications = FlutterLocalNotificationsPlugin();
  
  // Canales de notificación
  static const String alarmChannelId = 'alarm_channel';
  static const String snoozeChannelId = 'snooze_channel';
  static const String reminderChannelId = 'reminder_channel';
  
  // IDs de acciones
  static const String snoozeActionId = 'SNOOZE';
  static const String stopActionId = 'STOP';
  static const String openActionId = 'OPEN';

  Future<void> initialize() async {
    // Inicializar timezone
    tz.initializeTimeZones();

    // Configuración para Android
    const AndroidInitializationSettings androidSettings = 
        AndroidInitializationSettings('@mipmap/ic_launcher');

    const InitializationSettings settings = InitializationSettings(
      android: androidSettings,
    );

    // Inicializar plugin
    await _notifications.initialize(
      settings,
      onDidReceiveNotificationResponse: (NotificationResponse response) async {
        await _onNotificationResponse(response);
      },
      onDidReceiveBackgroundNotificationResponse: _onBackgroundNotificationResponse,
    );

    // Configurar canales
    await _setupNotificationChannels();
    
    // Solicitar permisos
    await _requestPermissions();
  }

  Future<void> _setupNotificationChannels() async {
    // Canal principal para alarmas
    const AndroidNotificationChannel alarmChannel = AndroidNotificationChannel(
      alarmChannelId,
      'Alarmas',
      description: 'Notificaciones de alarmas activas',
      importance: Importance.max,
      enableVibration: true,
      enableLights: true,
      playSound: true,
      sound: RawResourceAndroidNotificationSound('alarm_sound'),
      showBadge: true,
    );

    // Canal para recordatorios de snooze
    const AndroidNotificationChannel snoozeChannel = AndroidNotificationChannel(
      snoozeChannelId,
      'Posponer Alarmas',
      description: 'Notificaciones de alarmas pospuestas',
      importance: Importance.high,
      enableVibration: true,
      playSound: true,
    );

    // Canal para recordatorios generales
    const AndroidNotificationChannel reminderChannel = AndroidNotificationChannel(
      reminderChannelId,
      'Recordatorios',
      description: 'Recordatorios y avisos generales',
      importance: Importance.low, // Cambiado de default a low
      enableVibration: true,
    );

    final platform = _notifications.resolvePlatformSpecificImplementation<
        AndroidFlutterLocalNotificationsPlugin>();
    
    if (platform != null) {
      await platform.createNotificationChannel(alarmChannel);
      await platform.createNotificationChannel(snoozeChannel);
      await platform.createNotificationChannel(reminderChannel);
    }
  }

  // Método para programar alarmas
  Future<void> scheduleAlarm(Alarm alarm) async {
    final nextAlarmTime = alarm.getNextAlarmTime();
    
    const androidDetails = AndroidNotificationDetails(
      alarmChannelId,
      'Alarma Programada',
      channelDescription: 'Notificación de alarma programada',
      importance: Importance.max,
      priority: Priority.max,
      fullScreenIntent: true,
      category: AndroidNotificationCategory.alarm,
      actions: [
        AndroidNotificationAction(
          snoozeActionId,
          'Posponer',
          showsUserInterface: true,
          cancelNotification: false,
        ),
        AndroidNotificationAction(
          stopActionId,
          'Detener',
          showsUserInterface: true,
          cancelNotification: true,
        ),
      ],
    );

    await _notifications.zonedSchedule(
      alarm.id.hashCode,
      'Alarma programada - ${alarm.name}',
      'Sonará a las ${_formatTime(nextAlarmTime)}',
      tz.TZDateTime.from(nextAlarmTime, tz.local),
      const NotificationDetails(android: androidDetails),
      androidScheduleMode: AndroidScheduleMode.exactAllowWhileIdle,
      uiLocalNotificationDateInterpretation:
          UILocalNotificationDateInterpretation.absoluteTime,
      matchDateTimeComponents: alarm.isOneTime
          ? DateTimeComponents.time
          : DateTimeComponents.dayOfWeekAndTime,
      payload: alarm.toJsonString(),
    );
  }

  Future<void> showAlarmNotification(Alarm alarm) async {
    final now = DateTime.now();
    final bool isSnoozeAllowed = alarm.canSnooze();

    final List<AndroidNotificationAction> actions = [
      if (isSnoozeAllowed)
        const AndroidNotificationAction(
          snoozeActionId,
          'Posponer',
          showsUserInterface: true,
          cancelNotification: false,
        ),
      const AndroidNotificationAction(
        stopActionId,
        'Detener',
        showsUserInterface: true,
        cancelNotification: true,
      ),
    ];

    final androidDetails = AndroidNotificationDetails(
      alarmChannelId,
      'Alarma',
      channelDescription: 'Notificación de alarma activa',
      importance: Importance.max,
      priority: Priority.max,
      fullScreenIntent: true,
      actions: actions,
      category: AndroidNotificationCategory.alarm,
      sound: const RawResourceAndroidNotificationSound('alarm_sound'),
      playSound: true,
      enableVibration: true,
      vibrationPattern: Int64List.fromList([0, 500, 500, 500]),
      ongoing: true,
      autoCancel: false,
    );

    final details = NotificationDetails(android: androidDetails);

    await _notifications.show(
      alarm.id.hashCode,
      _getNotificationTitle(alarm),
      _getNotificationBody(alarm, now),
      details,
      payload: alarm.toJsonString(),
    );

    await _vibrate();
  }

  Future<void> showSnoozeNotification(Alarm alarm) async {
    final androidDetails = AndroidNotificationDetails(
      snoozeChannelId,
      'Alarma Pospuesta',
      channelDescription: 'Notificación de alarma pospuesta',
      importance: Importance.high,
      priority: Priority.high,
      enableVibration: true,
      autoCancel: true,
    );

    final details = NotificationDetails(android: androidDetails);

    await _notifications.show(
      alarm.id.hashCode + 1,
      'Alarma Pospuesta',
      'La alarma sonará nuevamente en ${alarm.snoozeTime} minutos',
      details,
      payload: alarm.toJsonString(),
    );
  }

  Future<void> _onNotificationResponse(NotificationResponse response) async {
    final String? payload = response.payload;
    if (payload == null) return;

    final alarm = Alarm.fromJsonString(payload);
    
    switch (response.actionId) {
      case snoozeActionId:
        await _handleSnooze(alarm);
        break;
      case stopActionId:
        await _handleStop(alarm);
        break;
      case openActionId:
      default:
        await _handleOpen(alarm);
        break;
    }
  }

  @pragma('vm:entry-point')
  static Future<void> _onBackgroundNotificationResponse(
    NotificationResponse response,
  ) async {
    // Manejar respuesta en segundo plano
    final notificationService = NotificationService();
    await notificationService._onNotificationResponse(response);
  }

  Future<void> _handleSnooze(Alarm alarm) async {
    final alarmService = AlarmService();
    
    if (!alarm.canSnooze()) {
      await showReminderNotification(
        'No se puede posponer',
        'Has alcanzado el límite de repeticiones',
      );
      return;
    }

    await alarmService.snoozeAlarm(alarm.id);
    await showSnoozeNotification(alarm);
    await _vibrate(pattern: [0, 100, 100, 100]);
  }

  Future<void> _handleStop(Alarm alarm) async {
    final alarmService = AlarmService();
    await alarmService.stopAlarm(alarm.id);
    await cancelAlarm(alarm.id);
    await _vibrate(pattern: [0, 50]);
  }

  Future<void> _handleOpen(Alarm alarm) async {
    // Se implementará cuando se añada la navegación
  }

  Future<void> cancelAlarm(String alarmId) async {
    await _notifications.cancel(alarmId.hashCode);
  }

  Future<void> cancelAllAlarms() async {
    await _notifications.cancelAll();
  }

  Future<void> _requestPermissions() async {
    final platform = _notifications
        .resolvePlatformSpecificImplementation<
            AndroidFlutterLocalNotificationsPlugin>();
            
    if (platform != null) {
      await platform.requestNotificationsPermission();
    }
  }

  Future<void> showReminderNotification(String title, String body) async {
    final androidDetails = AndroidNotificationDetails(
      reminderChannelId,
      'Recordatorio',
      channelDescription: 'Notificación de recordatorio',
      importance: Importance.low, // Cambiado de default a low
      priority: Priority.low, // Cambiado de default a low
      autoCancel: true,
    );

    final details = NotificationDetails(android: androidDetails);

    await _notifications.show(
      DateTime.now().millisecondsSinceEpoch.hashCode,
      title,
      body,
      details,
    );
  }

  String _getNotificationTitle(Alarm alarm) {
    if (alarm.name.isNotEmpty) {
      return '¡Alarma! - ${alarm.name}';
    }
    return '¡Alarma!';
  }

  String _getNotificationBody(Alarm alarm, DateTime now) {
    final timeStr = '${now.hour.toString().padLeft(2, '0')}:${now.minute.toString().padLeft(2, '0')}';
    if (alarm.requireGame) {
      return 'Son las $timeStr - Completa el juego para detener la alarma';
    }
    return 'Son las $timeStr';
  }

  Future<void> _vibrate({List<int>? pattern}) async {
    try {
      if (pattern != null) {
        await SystemChannels.platform.invokeMethod('HapticFeedback.vibrate', pattern);
      } else {
        await SystemChannels.platform.invokeMethod('HapticFeedback.vibrate');
      }
    } catch (e) {
      // Manejar error de vibración
      print('Error al vibrar: $e');
    }
  }

  String _formatTime(DateTime time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }
}

--------------------------------------------------

Ruta al script: lib/services/permission_service.dart
Nombre del script: permission_service.dart
Contenido del script:
import 'package:flutter/material.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:shared_preferences/shared_preferences.dart';

class PermissionService {
  static final PermissionService _instance = PermissionService._internal();
  factory PermissionService() => _instance;
  PermissionService._internal();

  static const String _tempSkipPermissionsKey = 'temp_skip_permissions';

  final List<Permission> _criticalPermissions = [
    Permission.notification,
    Permission.scheduleExactAlarm,
  ];

  final List<Permission> _backgroundPermissions = [
    Permission.systemAlertWindow,
    Permission.ignoreBatteryOptimizations,
  ];

  final List<Permission> _locationPermissions = [
    Permission.location,
    Permission.locationAlways,
    Permission.locationWhenInUse,
  ];

  final Map<Permission, bool> _permissionStatus = {};
  bool _temporarilySkipped = false;

  Future<bool> checkInitialPermissions() async {
    final prefs = await SharedPreferences.getInstance();
    _temporarilySkipped = prefs.getBool(_tempSkipPermissionsKey) ?? false;

    // Verificar permisos críticos
    for (var permission in _criticalPermissions) {
      final status = await permission.status;
      _permissionStatus[permission] = status.isGranted;
    }

    // Verificar permisos de segundo plano
    for (var permission in _backgroundPermissions) {
      final status = await permission.status;
      _permissionStatus[permission] = status.isGranted;
    }

    // Verificar permisos de ubicación
    for (var permission in _locationPermissions) {
      final status = await permission.status;
      _permissionStatus[permission] = status.isGranted;
    }

    return _criticalPermissions.every((p) => 
        _permissionStatus[p] == true) || _temporarilySkipped;
  }

  Future<void> temporarilySkipPermissions() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_tempSkipPermissionsKey, true);
    _temporarilySkipped = true;
  }

  Future<void> resetTemporarySkip() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.remove(_tempSkipPermissionsKey);
    _temporarilySkipped = false;
  }

  // Solicitar permisos críticos y mostrar diálogo para optimizaciones
  
  Future<bool> requestRequiredPermissions(BuildContext context) async {
    bool allGranted = true;

    // Solicitar permisos críticos
    for (var permission in _criticalPermissions) {
      final status = await permission.request();
      _permissionStatus[permission] = status.isGranted;
      if (!status.isGranted) allGranted = false;
    }

    // Solicitar permisos de segundo plano
    for (var permission in _backgroundPermissions) {
      await permission.request();
    }

    // Solicitar permisos de ubicación
    for (var permission in _locationPermissions) {
      await permission.request();
    }

    return allGranted;
  }

  Future<void> _showOptimizationDialog(BuildContext context) async {
    return showDialog(
      context: context,
      barrierDismissible: false,
      builder: (context) => AlertDialog(
        title: const Text('Optimización Recomendada'),
        content: Column(
          mainAxisSize: MainAxisSize.min,
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Text(
              'Para garantizar el mejor funcionamiento de las alarmas, recomendamos:',
              style: TextStyle(fontWeight: FontWeight.bold),
            ),
            const SizedBox(height: 16),
            _buildOptimizationItem(
              context,
              'Desactivar optimización de batería',
              'Para que las alarmas funcionen incluso en segundo plano',
              Permission.ignoreBatteryOptimizations,
            ),
            const SizedBox(height: 8),
            _buildOptimizationItem(
              context,
              'Permitir control de sonido',
              'Para gestionar el volumen de las alarmas',
              Permission.accessNotificationPolicy,
            ),
          ],
        ),
        actions: [
          TextButton(
            onPressed: () async {
              await temporarilySkipPermissions();
              if (context.mounted) {
                Navigator.pop(context);
              }
            },
            child: const Text('Más tarde'),
          ),
          ElevatedButton(
            onPressed: () async {
              Navigator.pop(context);
              await openAppSettings();
            },
            child: const Text('Configurar'),
          ),
        ],
      ),
    );
  }

  Widget _buildOptimizationItem(
    BuildContext context,
    String title,
    String description,
    Permission permission,
  ) {
    return FutureBuilder<bool>(
      future: permission.isGranted,
      builder: (context, snapshot) {
        final isGranted = snapshot.data ?? false;
        return Row(
          children: [
            Icon(
              isGranted ? Icons.check_circle : Icons.warning,
              color: isGranted ? Colors.green : Colors.orange,
            ),
            const SizedBox(width: 8),
            Expanded(
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(
                    title,
                    style: const TextStyle(fontWeight: FontWeight.bold),
                  ),
                  Text(
                    description,
                    style: Theme.of(context).textTheme.bodySmall,
                  ),
                ],
              ),
            ),
          ],
        );
      },
    );
  }

  bool get areAllCriticalPermissionsGranted {
    return _criticalPermissions.every(
      (permission) => _permissionStatus[permission] == true,
    ) || _temporarilySkipped;
  }

  bool isPermissionGranted(Permission permission) {
    return _permissionStatus[permission] ?? false;
  }


}

--------------------------------------------------

Ruta al script: lib/services/sound_service.dart
Nombre del script: sound_service.dart
Contenido del script:
import 'package:flutter/services.dart';

class SoundService {
  static final SoundService _instance = SoundService._internal();
  factory SoundService() => _instance;
  SoundService._internal();

  static const platform = MethodChannel('com.example.alarm/sound');

  Future<void> playAlarmSound() async {
    try {
      await platform.invokeMethod('playAlarmSound');
    } catch (e) {
      print('Error playing alarm sound: $e');
    }
  }

  Future<void> stopAlarmSound() async {
    try {
      await platform.invokeMethod('stopAlarmSound');
    } catch (e) {
      print('Error stopping alarm sound: $e');
    }
  }
}

--------------------------------------------------

Ruta al script: lib/services/vibration_service.dart
Nombre del script: vibration_service.dart
Contenido del script:
import 'package:flutter/services.dart';
import 'package:shared_preferences/shared_preferences.dart';

class VibrationService {
  static final VibrationService _instance = VibrationService._internal();
  factory VibrationService() => _instance;
  VibrationService._internal();

  static const String _prefVibrationEnabled = 'vibration_enabled';
  static const String _prefVibrationPattern = 'vibration_pattern';

  // Patrones predefinidos (duración en milisegundos)
  static const Map<String, List<int>> vibrationPatterns = {
    'suave': [0, 200, 200, 200],
    'normal': [0, 500, 200, 500],
    'intenso': [0, 1000, 200, 1000, 200, 1000],
    'sos': [0, 100, 100, 100, 100, 100, 200, 200, 200, 100, 100, 100],
    'escalado': [0, 100, 100, 200, 100, 300, 100, 400],
  };

  bool _isEnabled = true;
  String _currentPattern = 'normal';
  
  // Inicializar el servicio
  Future<void> initialize() async {
    final prefs = await SharedPreferences.getInstance();
    _isEnabled = prefs.getBool(_prefVibrationEnabled) ?? true;
    _currentPattern = prefs.getString(_prefVibrationPattern) ?? 'normal';
  }

  // Getters y Setters
  bool get isEnabled => _isEnabled;
  String get currentPattern => _currentPattern;

  Future<void> setEnabled(bool enabled) async {
    _isEnabled = enabled;
    final prefs = await SharedPreferences.getInstance();
    await prefs.setBool(_prefVibrationEnabled, enabled);
  }

  Future<void> setPattern(String pattern) async {
    if (vibrationPatterns.containsKey(pattern)) {
      _currentPattern = pattern;
      final prefs = await SharedPreferences.getInstance();
      await prefs.setString(_prefVibrationPattern, pattern);
    }
  }

  // Métodos de vibración
  Future<void> vibrate({String? pattern}) async {
    if (!_isEnabled) return;

    try {
      final selectedPattern = pattern ?? _currentPattern;
      final vibrationPattern = vibrationPatterns[selectedPattern] ?? vibrationPatterns['normal']!;

      // Usar la plataforma para vibrar
      await SystemChannels.platform.invokeMethod('HapticFeedback.vibrate', vibrationPattern);
    } catch (e) {
      print('Error al vibrar: $e');
    }
  }

  // Vibración de prueba
  Future<void> testVibration(String pattern) async {
    if (!_isEnabled) return;
    await vibrate(pattern: pattern);
  }

  // Vibración de alarma
  Future<void> startAlarmVibration() async {
    if (!_isEnabled) return;
    
    // Patrón continuo para alarma
    while (_isEnabled) {
      await vibrate();
      await Future.delayed(const Duration(seconds: 1));
    }
  }

  // Detener vibración
  void stopVibration() {
    _isEnabled = false;
  }

  // Vibración de confirmación
  Future<void> vibrateConfirmation() async {
    if (!_isEnabled) return;
    await vibrate(pattern: 'suave');
  }

  // Vibración de error
  Future<void> vibrateError() async {
    if (!_isEnabled) return;
    await vibrate(pattern: 'sos');
  }
}

--------------------------------------------------

Ruta al script: lib/screens/games/math_game_screen.dart
Nombre del script: math_game_screen.dart
Contenido del script:
import 'dart:math';
import 'package:flutter/material.dart';
import '../../widgets/game_widgets/math_problem_widget.dart';

class MathGameScreen extends StatefulWidget {
  final String difficulty;
  final VoidCallback onGameComplete;
  final VoidCallback onGameFailed;

  const MathGameScreen({
    super.key,
    required this.difficulty,
    required this.onGameComplete,
    required this.onGameFailed,
  });

  @override
  State<MathGameScreen> createState() => _MathGameScreenState();
}

class _MathGameScreenState extends State<MathGameScreen> {
  late List<MathProblem> _problems;
  late int _currentProblemIndex;
  late int _timeLeft;
  late bool _isTimerRunning;
  
  final _answerController = TextEditingController();
  final _random = Random();

  @override
  void initState() {
    super.initState();
    _initializeGame();
  }

  void _initializeGame() {
    _problems = _generateProblems();
    _currentProblemIndex = 0;
    _timeLeft = _getTimeLimit();
    _isTimerRunning = true;
    _startTimer();
  }

  List<MathProblem> _generateProblems() {
    final int problemCount = _getProblemCount();
    final int maxNumber = _getMaxNumber();
    final List<String> operations = _getOperations();
    final List<MathProblem> problems = [];

    for (int i = 0; i < problemCount; i++) {
      final operation = operations[_random.nextInt(operations.length)];
      final problem = _generateProblem(operation, maxNumber);
      problems.add(problem);
    }

    return problems;
  }

  int _getProblemCount() {
    switch (widget.difficulty) {
      case 'easy':
        return 3;
      case 'medium':
        return 5;
      case 'hard':
        return 7;
      default:
        return 3;
    }
  }

  int _getTimeLimit() {
    switch (widget.difficulty) {
      case 'easy':
        return 120; // 2 minutos
      case 'medium':
        return 180; // 3 minutos
      case 'hard':
        return 240; // 4 minutos
      default:
        return 120;
    }
  }

  int _getMaxNumber() {
    switch (widget.difficulty) {
      case 'easy':
        return 10;
      case 'medium':
        return 25;
      case 'hard':
        return 100;
      default:
        return 10;
    }
  }

  List<String> _getOperations() {
    switch (widget.difficulty) {
      case 'easy':
        return ['+', '-'];
      case 'medium':
        return ['+', '-', '*'];
      case 'hard':
        return ['+', '-', '*', '/'];
      default:
        return ['+', '-'];
    }
  }

  MathProblem _generateProblem(String operation, int maxNumber) {
    late int num1, num2, answer;
    
    switch (operation) {
      case '+':
        num1 = _random.nextInt(maxNumber);
        num2 = _random.nextInt(maxNumber);
        answer = num1 + num2;
        break;
      case '-':
        num1 = _random.nextInt(maxNumber);
        num2 = _random.nextInt(num1 + 1); // Asegurar resultado positivo
        answer = num1 - num2;
        break;
      case '*':
        num1 = _random.nextInt((sqrt(maxNumber)).toInt());
        num2 = _random.nextInt((sqrt(maxNumber)).toInt());
        answer = num1 * num2;
        break;
      case '/':
        num2 = _random.nextInt((sqrt(maxNumber)).toInt()) + 1;
        answer = _random.nextInt(maxNumber ~/ num2);
        num1 = answer * num2;
        break;
      default:
        num1 = _random.nextInt(maxNumber);
        num2 = _random.nextInt(maxNumber);
        answer = num1 + num2;
        operation = '+';
    }

    return MathProblem(
      num1: num1,
      num2: num2,
      operation: operation,
      answer: answer,
    );
  }

  void _startTimer() {
    Future.delayed(const Duration(seconds: 1), () {
      if (!mounted) return;

      setState(() {
        if (_isTimerRunning && _timeLeft > 0) {
          _timeLeft--;
          if (_timeLeft > 0) {
            _startTimer();
          } else {
            _handleTimeout();
          }
        }
      });
    });
  }

  void _handleTimeout() {
    _isTimerRunning = false;
    widget.onGameFailed();
  }

  void _checkAnswer() {
    final int? userAnswer = int.tryParse(_answerController.text);
    if (userAnswer == null) return;

    if (userAnswer == _problems[_currentProblemIndex].answer) {
      _answerController.clear();
      
      if (_currentProblemIndex < _problems.length - 1) {
        setState(() {
          _currentProblemIndex++;
        });
      } else {
        _isTimerRunning = false;
        widget.onGameComplete();
      }
    } else {
      // Mostrar error
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Respuesta incorrecta, intenta de nuevo'),
          duration: Duration(seconds: 2),
        ),
      );
    }
  }

  @override
  void dispose() {
    _answerController.dispose();
    _isTimerRunning = false;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Juego de Matemáticas'),
        actions: [
          Center(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Text(
                'Tiempo: ${_timeLeft}s',
                style: const TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          LinearProgressIndicator(
            value: (_currentProblemIndex + 1) / _problems.length,
            backgroundColor: Colors.grey[200],
            valueColor: AlwaysStoppedAnimation<Color>(
              Theme.of(context).colorScheme.primary,
            ),
          ),
          Expanded(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Center(
                child: SingleChildScrollView(
                  child: Column(
                    mainAxisAlignment: MainAxisAlignment.center,
                    children: [
                      Text(
                        'Problema ${_currentProblemIndex + 1} de ${_problems.length}',
                        style: Theme.of(context).textTheme.titleLarge,
                      ),
                      const SizedBox(height: 32),
                      MathProblemWidget(
                        problem: _problems[_currentProblemIndex],
                      ),
                      const SizedBox(height: 32),
                      TextField(
                        controller: _answerController,
                        keyboardType: TextInputType.number,
                        textAlign: TextAlign.center,
                        style: const TextStyle(fontSize: 24),
                        decoration: const InputDecoration(
                          hintText: 'Tu respuesta',
                          border: OutlineInputBorder(),
                        ),
                        onSubmitted: (_) => _checkAnswer(),
                      ),
                      const SizedBox(height: 16),
                      ElevatedButton(
                        onPressed: _checkAnswer,
                        child: const Text('Verificar'),
                      ),
                    ],
                  ),
                ),
              ),
            ),
          ),
        ],
      ),
    );
  }
}

class MathProblem {
  final int num1;
  final int num2;
  final String operation;
  final int answer;

  MathProblem({
    required this.num1,
    required this.num2,
    required this.operation,
    required this.answer,
  });

  @override
  String toString() {
    return '$num1 $operation $num2 = ?';
  }
}

--------------------------------------------------

Ruta al script: lib/screens/games/memory_game_screen.dart
Nombre del script: memory_game_screen.dart
Contenido del script:
import 'dart:async';
import 'dart:math';
import 'package:flutter/material.dart';
import '../../widgets/game_widgets/memory_card_widget.dart';

class MemoryGameScreen extends StatefulWidget {
  final String difficulty;
  final VoidCallback onGameComplete;
  final VoidCallback onGameFailed;

  const MemoryGameScreen({
    super.key,
    required this.difficulty,
    required this.onGameComplete,
    required this.onGameFailed,
  });

  @override
  State<MemoryGameScreen> createState() => _MemoryGameScreenState();
}

class _MemoryGameScreenState extends State<MemoryGameScreen> {
  late List<MemoryCard> _cards;
  late int _timeLeft;
  late bool _isTimerRunning;
  final List<int> _selectedIndices = [];
  int _matchedPairs = 0;
  bool _canFlipCards = true;

  @override
  void initState() {
    super.initState();
    _initializeGame();
  }

  void _initializeGame() {
    _cards = _generateCards();
    _timeLeft = _getTimeLimit();
    _isTimerRunning = true;
    _matchedPairs = 0;
    _startTimer();
  }

  List<MemoryCard> _generateCards() {
    final int pairCount = _getPairCount();
    final List<MemoryCard> cards = [];
    final List<int> values = List.generate(pairCount, (index) => index);
    final random = Random();

    // Crear pares de cartas
    for (int value in values) {
      for (int i = 0; i < 2; i++) {
        cards.add(MemoryCard(
          value: value,
          isFlipped: false,
          isMatched: false,
        ));
      }
    }

    // Mezclar las cartas
    for (int i = cards.length - 1; i > 0; i--) {
      int randomIndex = random.nextInt(i + 1);
      MemoryCard temp = cards[i];
      cards[i] = cards[randomIndex];
      cards[randomIndex] = temp;
    }

    return cards;
  }

  int _getPairCount() {
    switch (widget.difficulty) {
      case 'easy':
        return 6;  // 12 cartas
      case 'medium':
        return 12; // 24 cartas
      case 'hard':
        return 18; // 36 cartas
      default:
        return 6;
    }
  }

  int _getTimeLimit() {
    switch (widget.difficulty) {
      case 'easy':
        return 60;  // 1 minuto
      case 'medium':
        return 120; // 2 minutos
      case 'hard':
        return 180; // 3 minutos
      default:
        return 60;
    }
  }

  void _startTimer() {
    Future.delayed(const Duration(seconds: 1), () {
      if (!mounted) return;

      setState(() {
        if (_isTimerRunning && _timeLeft > 0) {
          _timeLeft--;
          if (_timeLeft > 0) {
            _startTimer();
          } else {
            _handleTimeout();
          }
        }
      });
    });
  }

  void _handleTimeout() {
    _isTimerRunning = false;
    widget.onGameFailed();
  }

  void _onCardTap(int index) {
    if (!_canFlipCards || 
        _cards[index].isFlipped || 
        _cards[index].isMatched ||
        _selectedIndices.contains(index)) {
      return;
    }

    setState(() {
      _cards[index].isFlipped = true;
      _selectedIndices.add(index);
    });

    if (_selectedIndices.length == 2) {
      _canFlipCards = false;
      _checkMatch();
    }
  }

  void _checkMatch() {
    final card1 = _cards[_selectedIndices[0]];
    final card2 = _cards[_selectedIndices[1]];

    if (card1.value == card2.value) {
      // Es un par
      setState(() {
        card1.isMatched = true;
        card2.isMatched = true;
        _matchedPairs++;
        _selectedIndices.clear();
        _canFlipCards = true;
      });

      if (_matchedPairs == _getPairCount()) {
        _isTimerRunning = false;
        widget.onGameComplete();
      }
    } else {
      // No es un par
      Future.delayed(const Duration(milliseconds: 1000), () {
        if (!mounted) return;
        setState(() {
          card1.isFlipped = false;
          card2.isFlipped = false;
          _selectedIndices.clear();
          _canFlipCards = true;
        });
      });
    }
  }

  @override
  void dispose() {
    _isTimerRunning = false;
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final gridSize = _getGridSize();

    return Scaffold(
      appBar: AppBar(
        title: const Text('Juego de Memoria'),
        actions: [
          Center(
            child: Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: Text(
                'Tiempo: ${_timeLeft}s',
                style: const TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
          ),
        ],
      ),
      body: Column(
        children: [
          LinearProgressIndicator(
            value: _matchedPairs / _getPairCount(),
            backgroundColor: Colors.grey[200],
            valueColor: AlwaysStoppedAnimation<Color>(
              Theme.of(context).colorScheme.primary,
            ),
          ),
          Expanded(
            child: Padding(
              padding: const EdgeInsets.all(8.0),
              child: GridView.builder(
                gridDelegate: SliverGridDelegateWithFixedCrossAxisCount(
                  crossAxisCount: gridSize,
                  crossAxisSpacing: 4,
                  mainAxisSpacing: 4,
                  childAspectRatio: 1,
                ),
                itemCount: _cards.length,
                itemBuilder: (context, index) {
                  return MemoryCardWidget(
                    card: _cards[index],
                    onTap: () => _onCardTap(index),
                  );
                },
              ),
            ),
          ),
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              'Pares encontrados: $_matchedPairs/${_getPairCount()}',
              style: Theme.of(context).textTheme.titleLarge,
            ),
          ),
        ],
      ),
    );
  }

  int _getGridSize() {
    switch (widget.difficulty) {
      case 'easy':
        return 3;  // 3x4 grid
      case 'medium':
        return 4;  // 4x6 grid
      case 'hard':
        return 6;  // 6x6 grid
      default:
        return 3;
    }
  }
}

class MemoryCard {
  final int value;
  bool isFlipped;
  bool isMatched;

  MemoryCard({
    required this.value,
    this.isFlipped = false,
    this.isMatched = false,
  });
}

--------------------------------------------------

Ruta al script: lib/screens/active_alarms_screen.dart
Nombre del script: active_alarms_screen.dart
Contenido del script:
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:the_good_alarm/widgets/alarm_list_item.dart';
import '../models/alarm.dart';
import '../services/alarm_service.dart';
import './alarm_edit_screen.dart';

class ActiveAlarmsScreen extends StatelessWidget {
  const ActiveAlarmsScreen({super.key});

  @override
  Widget build(BuildContext context) {
    final alarmService = Provider.of<AlarmService>(context);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Alarmas Activas'),
        actions: [
          // Acciones adicionales si se requieren
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: () {
              // Navegar a configuración de alarmas activas
            },
          ),
        ],
      ),
      body: StreamBuilder<List<Alarm>>(
        stream: alarmService.activeAlarmsStream,
        initialData: alarmService.activeAlarms,
        builder: (context, snapshot) {
          // Estado de carga
          // if (snapshot.connectionState == ConnectionState.waiting) {
          //   return const Center(
          //     child: CircularProgressIndicator(),
          //   );
          // }

          // Error
          if (snapshot.hasError) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  const Icon(
                    Icons.error_outline,
                    color: Colors.red,
                    size: 60,
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'Error al cargar alarmas activas',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  Text(snapshot.error.toString()),
                  ElevatedButton(
                    onPressed: () => alarmService.initialize(),
                    child: const Text('Reintentar'),
                  )
                ],
              ),
            );
          }

          // Sin alarmas activas
          final activeAlarms = snapshot.data ?? [];
          if (activeAlarms.isEmpty) {
            return Center(
              child: Column(
                mainAxisAlignment: MainAxisAlignment.center,
                children: [
                  Icon(
                    Icons.alarm_off,
                    size: 64,
                    color: Theme.of(context).colorScheme.primary.withOpacity(0.5),
                  ),
                  const SizedBox(height: 16),
                  Text(
                    'No hay alarmas activas',
                    style: Theme.of(context).textTheme.titleLarge,
                  ),
                  const SizedBox(height: 8),
                  Text(
                    'Activa algunas alarmas para verlas aquí',
                    style: Theme.of(context).textTheme.bodyMedium,
                  ),
                ],
              ),
            );
          }

          // Lista de alarmas activas
          return ListView.separated(
            itemCount: activeAlarms.length,
            separatorBuilder: (context, index) => const Divider(height: 1),
            itemBuilder: (context, index) {
              final alarm = activeAlarms[index];
              return AlarmListItem(
                alarm: alarm,
                onTap: () {
                  // Navegación a edición de alarma
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => AlarmEditScreen(alarm: alarm),
                    ),
                  );
                },
                onToggle: (enabled) {
                  alarmService.toggleAlarm(alarm.id);
                },
                onDelete: () {
                  alarmService.deleteAlarm(alarm.id);
                },
              );
            },
          );
        },
      ),
      floatingActionButton: FloatingActionButton(
        onPressed: () {
          // Navegación a creación de nueva alarma
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => const AlarmEditScreen(),
            ),
          );
        },
        child: const Icon(Icons.add),
      ),
    );
  }
  
  void _showDeleteConfirmation(
    BuildContext context, 
    AlarmService alarmService, 
    Alarm alarm
  ) {
    showDialog(
      context: context,
      builder: (context) => AlertDialog(
        title: const Text('Eliminar Alarma'),
        content: const Text('¿Estás seguro de eliminar esta alarma?'),
        actions: [
          TextButton(
            onPressed: () => Navigator.pop(context),
            child: const Text('Cancelar'),
          ),
          ElevatedButton(
            onPressed: () {
              alarmService.deleteAlarm(alarm.id);
              Navigator.pop(context);
            },
            child: const Text('Eliminar'),
          ),
        ],
      ),
    );
  }

  String _formatTime(DateTime time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }
}

--------------------------------------------------

Ruta al script: lib/screens/alarm_edit_screen.dart
Nombre del script: alarm_edit_screen.dart
Contenido del script:
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/alarm.dart';
import '../services/alarm_service.dart';
import '../configuracion/app_settings.dart';
import '../widgets/custom_numpad.dart';
import '../widgets/circular_time_picker.dart';
import 'game_selection_screen.dart';

class AlarmEditScreen extends StatefulWidget {
  final Alarm? alarm;

  const AlarmEditScreen({
    super.key,
    this.alarm,
  });

  @override
  State<AlarmEditScreen> createState() => _AlarmEditScreenState();
}

class _AlarmEditScreenState extends State<AlarmEditScreen> {
  late TextEditingController _nameController;
  late TimeOfDay _selectedTime;
  late List<bool> _selectedDays;
  late bool _isOneTime;
  late bool _requireGame;
  String? _selectedGame;
  String? _gameDifficulty;
  late int _snoozeTime;
  bool _useVibration = true;
  @override
  void initState() {
    super.initState();
    _initializeValues();
  }

  void _initializeValues() {
    final now = TimeOfDay.now();
    _nameController = TextEditingController(text: widget.alarm?.name ?? '');
    _selectedTime = widget.alarm != null
        ? TimeOfDay(
            hour: widget.alarm!.time.hour,
            minute: widget.alarm!.time.minute,
          )
        : now;
    _selectedDays = widget.alarm?.weekDays ?? List.filled(7, false);
    _isOneTime = widget.alarm?.isOneTime ?? true;
    _requireGame = widget.alarm?.requireGame ?? false;
    _selectedGame = widget.alarm?.selectedGame;
    _gameDifficulty = widget.alarm?.gameDifficulty;
    _snoozeTime = widget.alarm?.snoozeTime ?? 5;
    _useVibration = widget.alarm?.useVibration ?? true;
  }

  @override
  void dispose() {
    _nameController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final appSettings = Provider.of<AppSettings>(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(widget.alarm == null ? 'Nueva Alarma' : 'Editar Alarma'),
        actions: [
          IconButton(
            icon: const Icon(Icons.save),
            onPressed: _saveAlarm,
          ),
        ],
      ),
      body: SingleChildScrollView(
        child: Column(
          children: [
            // Selector de hora
            Padding(
              padding: const EdgeInsets.all(16.0),
              child: appSettings.inputFormat == InputFormat.numpad
                  ? TimeInputWithNumpad(
                      onTimeSelected: (time) {
                        setState(() => _selectedTime = time);
                      },
                    )
                  : CircularTimePicker(
                      initialTime: _selectedTime,
                      onTimeChanged: (time) {
                        setState(() => _selectedTime = time);
                      },
                      use24HourFormat: appSettings.timeFormat == TimeFormat.h24,
                    ),
            ),

            // Nombre de la alarma
            Padding(
              padding: const EdgeInsets.symmetric(horizontal: 16.0),
              child: TextField(
                controller: _nameController,
                decoration: const InputDecoration(
                  labelText: 'Nombre de la alarma',
                  hintText: 'Ejemplo: Trabajo, Gimnasio...',
                  prefixIcon: Icon(Icons.label),
                ),
              ),
            ),

            const SizedBox(height: 16),

            // Selector de días
            if (!_isOneTime) ...[
              const Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(
                  'Repetir en',
                  style: TextStyle(fontWeight: FontWeight.bold),
                ),
              ),
              _buildDaySelector(),
            ],

            // Switch para alarma única
            SwitchListTile(
              title: const Text('Alarma de una sola vez'),
              subtitle: const Text('La alarma sonará solo una vez'),
              value: _isOneTime,
              onChanged: (value) {
                setState(() => _isOneTime = value);
              },
            ),

            const Divider(),

            // Configuración del juego
            SwitchListTile(
              title: const Text('Requerir juego para apagar'),
              subtitle: const Text(
                  'Deberás completar un juego para apagar la alarma'),
              value: _requireGame,
              onChanged: (value) {
                setState(() => _requireGame = value);
                if (value && _selectedGame == null) {
                  _selectGame();
                }
              },
            ),

            if (_requireGame) ...[
              ListTile(
                title: Text(_selectedGame == null
                    ? 'Seleccionar juego'
                    : 'Juego: ${_getGameName(_selectedGame!)}'),
                subtitle: _gameDifficulty != null
                    ? Text(
                        'Dificultad: ${_getGameDifficulty(_gameDifficulty!)}')
                    : null,
                trailing: const Icon(Icons.chevron_right),
                onTap: _selectGame,
              ),
            ],

            const Divider(),

            // Configuración de snooze
            ListTile(
              title: const Text('Tiempo de repetición'),
              subtitle: Text('$_snoozeTime minutos'),
              trailing: Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  IconButton(
                    icon: const Icon(Icons.remove),
                    onPressed: _snoozeTime > 1
                        ? () => setState(() => _snoozeTime--)
                        : null,
                  ),
                  Text('$_snoozeTime'),
                  IconButton(
                    icon: const Icon(Icons.add),
                    onPressed: _snoozeTime < 30
                        ? () => setState(() => _snoozeTime++)
                        : null,
                  ),
                ],
              ),
            ),
            ListTile(
              title: const Text('Vibración'),
              subtitle: const Text('Vibrar cuando suene la alarma'),
              trailing: Switch(
                value: _useVibration,
                onChanged: (value) {
                  setState(() {
                    _useVibration = value;
                  });
                },
              ),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDaySelector() {
    const days = ['L', 'M', 'M', 'J', 'V', 'S', 'D'];

    return Wrap(
      spacing: 8,
      alignment: WrapAlignment.center,
      children: List.generate(7, (index) {
        return FilterChip(
          label: Text(days[index]),
          selected: _selectedDays[index],
          onSelected: (selected) {
            setState(() {
              _selectedDays[index] = selected;
            });
          },
        );
      }),
    );
  }

  Future<void> _selectGame() async {
    final result = await Navigator.push<Map<String, String>>(
      context,
      MaterialPageRoute(
        builder: (context) => GameSelectionScreen(
          selectedGame: _selectedGame,
          difficulty: _gameDifficulty,
        ),
      ),
    );

    if (result != null) {
      setState(() {
        _selectedGame = result['game'];
        _gameDifficulty = result['difficulty'];
      });
    }
  }

  String _getGameName(String game) {
    switch (game) {
      case 'math':
        return 'Matemáticas';
      case 'memory':
        return 'Memoria';
      default:
        return 'Desconocido';
    }
  }

  String _getGameDifficulty(String difficulty) {
    switch (difficulty) {
      case 'easy':
        return 'Fácil';
      case 'medium':
        return 'Media';
      case 'hard':
        return 'Difícil';
      default:
        return 'Desconocida';
    }
  }

  Future<void> _saveAlarm() async {
    if (!_isOneTime && !_selectedDays.contains(true)) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Selecciona al menos un día para la alarma recurrente'),
        ),
      );
      return;
    }

    if (_requireGame && (_selectedGame == null || _gameDifficulty == null)) {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(
          content: Text('Selecciona un juego y su dificultad'),
        ),
      );
      return;
    }

    final alarmService = Provider.of<AlarmService>(context, listen: false);
    final now = DateTime.now();
    final dateTime = DateTime(
      now.year,
      now.month,
      now.day,
      _selectedTime.hour,
      _selectedTime.minute,
    );

    final newAlarm = Alarm(
      id: widget.alarm?.id ?? DateTime.now().millisecondsSinceEpoch.toString(),
      name: _nameController.text,
      time: dateTime,
      isEnabled: true,
      weekDays: _selectedDays,
      isOneTime: _isOneTime,
      snoozeTime: _snoozeTime,
      requireGame: _requireGame,
      selectedGame: _selectedGame,
      gameDifficulty: _gameDifficulty,
      useVibration: _useVibration,
    );

    if (widget.alarm != null) {
      await alarmService.updateAlarm(newAlarm);
    } else {
      await alarmService.addAlarm(newAlarm);
    }

    if (mounted) {
      Navigator.pop(context);
    }
  }
}


--------------------------------------------------

Ruta al script: lib/screens/alarm_history_screen.dart
Nombre del script: alarm_history_screen.dart
Contenido del script:
import 'package:flutter/material.dart';
import '../services/alarm_history_service.dart';
import '../models/alarm_history_entry.dart';

class AlarmHistoryScreen extends StatelessWidget {
  AlarmHistoryScreen({super.key}); // Añadir key y hacerlo const
  final AlarmHistoryService _historyService = AlarmHistoryService();

  @override
  Widget build(BuildContext context) {
    final historyEntries = _historyService.getAllHistory();

    return Scaffold(
      appBar: AppBar(title: Text('Historial de Alarmas')),
      body: ListView.builder(
        itemCount: historyEntries.length,
        itemBuilder: (context, index) {
          final entry = historyEntries[index];
          return ListTile(
            title: Text(_getEventTitle(entry.eventType)),
            subtitle: Text('Alarma: ${entry.alarmId}'),
            trailing: Text(_formatDateTime(entry.timestamp)),
          );
        },
      ),
    );
  }

  String _getEventTitle(AlarmEventType eventType) {
    switch (eventType) {
      case AlarmEventType.created:
        return 'Alarma Creada';
      case AlarmEventType.snoozed:
        return 'Alarma Pospuesta';
      // Añade más casos según sea necesario
      default:
        return eventType.toString();
    }
  }

  String _formatDateTime(DateTime dateTime) {
    // Implementa un formato de fecha personalizado
    return '${dateTime.day}/${dateTime.month}/${dateTime.year} ${dateTime.hour}:${dateTime.minute}';
  }
}

--------------------------------------------------

Ruta al script: lib/screens/alarm_list_screen.dart
Nombre del script: alarm_list_screen.dart
Contenido del script:
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:the_good_alarm/widgets/intervalos.dart';
import '../models/time_interval_settings.dart';
import '../services/alarm_service.dart';
import '../models/alarm.dart';
import 'alarm_edit_screen.dart';

class AlarmListScreen extends StatefulWidget {
  const AlarmListScreen({super.key});

  @override
  State<AlarmListScreen> createState() => _AlarmListScreenState();
}

class _AlarmListScreenState extends State<AlarmListScreen> {
  late TimeIntervalSettings _intervalSettings;

  @override
  void initState() {
    super.initState();
    _loadIntervalSettings();
  }

  Future<void> _loadIntervalSettings() async {
    final settings = await TimeIntervalSettings.load();
    setState(() {
      _intervalSettings = settings;
    });
  }

  String _formatTimeOfDay(TimeOfDay time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  List<Alarm> _filterAlarmsByInterval(
      List<Alarm> alarms, TimeOfDay start, TimeOfDay end) {
    return alarms.where((alarm) {
      final alarmTime = TimeOfDay.fromDateTime(alarm.time);
      return _isTimeInInterval(alarmTime, start, end);
    }).toList();
  }

  bool _isTimeInInterval(TimeOfDay time, TimeOfDay start, TimeOfDay end) {
    final startMinutes = start.hour * 60 + start.minute;
    final endMinutes = end.hour * 60 + end.minute;
    final timeMinutes = time.hour * 60 + time.minute;

    // Manejar caso de intervalo que cruza la media noche
    if (endMinutes < startMinutes) {
      return timeMinutes >= startMinutes || timeMinutes <= endMinutes;
    }

    return timeMinutes >= startMinutes && timeMinutes <= endMinutes;
  }

  @override
  Widget build(BuildContext context) {
    final alarmService = Provider.of<AlarmService>(context, listen: false);

    return Scaffold(
      appBar: AppBar(
        title: const Text('Todas las Alarmas'),
        actions: [
          IconButton(
            icon: const Icon(Icons.settings),
            onPressed: _showIntervalConfigModal,
          ),
        ],
      ),
      body: RefreshIndicator(
        onRefresh: () async {
          await alarmService.initialize();
        },
        child: StreamBuilder<List<Alarm>>(
          stream: alarmService.alarmsStream,
          initialData: alarmService.alarms,
          builder: (context, snapshot) {
        // child: Consumer<AlarmService>(
          // builder: (context, alarmService, child) {
            final alarms = alarmService.alarms;
            final morningAlarms = _filterAlarmsByInterval(alarms,
                _intervalSettings.morningStart, _intervalSettings.morningEnd);
            final afternoonAlarms = _filterAlarmsByInterval(
                alarms,
                _intervalSettings.afternoonStart,
                _intervalSettings.afternoonEnd);
            final nightAlarms = _filterAlarmsByInterval(alarms,
                _intervalSettings.nightStart, _intervalSettings.nightEnd);

            // Verificar si no hay alarmas en absoluto
            if (alarms.isEmpty) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.alarm_off,
                      size: 64,
                      color: Theme.of(context)
                          .colorScheme
                          .primary
                          .withOpacity(0.5),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'No hay alarmas',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Crea tu primera alarma',
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
              );
            }

            return ListView(
              children: [
                _buildAlarmSection('Mañana', morningAlarms,
                    '${_formatTimeOfDay(_intervalSettings.morningStart)} - ${_formatTimeOfDay(_intervalSettings.morningEnd)}'),
                _buildAlarmSection('Tarde', afternoonAlarms,
                    '${_formatTimeOfDay(_intervalSettings.afternoonStart)} - ${_formatTimeOfDay(_intervalSettings.afternoonEnd)}'),
                _buildAlarmSection('Noche', nightAlarms,
                    '${_formatTimeOfDay(_intervalSettings.nightStart)} - ${_formatTimeOfDay(_intervalSettings.nightEnd)}'),
              ],
            );
          },
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _navigateToAlarmEdit(context),
        icon: const Icon(Icons.add),
        label: const Text('Nueva Alarma'),
      ),
    );
  }

  Widget _buildAlarmSection(
      String title, List<Alarm> alarms, String timeInterval) {
    return ExpansionTile(
      title: Row(
        children: [
          Text(title),
          const SizedBox(width: 10),
          Text(
            timeInterval,
            style: const TextStyle(
              fontSize: 12,
              color: Colors.grey,
            ),
          ),
        ],
      ),
      initiallyExpanded: true,
      children: alarms.isEmpty
          ? [const ListTile(title: Text('No hay alarmas'))]
          : alarms.map((alarm) => _buildAlarmTile(alarm)).toList(),
    );
  }

  Widget _buildAlarmTile(Alarm alarm) {
    return ListTile(
      title: Text(alarm.name.isEmpty ? 'Alarma' : alarm.name),
      subtitle: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Text(
            '${alarm.time.hour.toString().padLeft(2, '0')}:${alarm.time.minute.toString().padLeft(2, '0')}',
            style: const TextStyle(fontWeight: FontWeight.bold),
          ),
          Text(
            alarm.isOneTime ? 'Una vez' : 'Repetir',
            style: TextStyle(
              color: alarm.isOneTime ? Colors.red : Colors.green,
              fontSize: 12,
            ),
          ),
        ],
      ),
      trailing: Switch(
        value: alarm.isEnabled,
        onChanged: (_) => _toggleAlarm(alarm),
      ),
      onTap: () => _showAlarmOptions(alarm),
    );
  }

  void _showAlarmOptions(Alarm alarm) {
    showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return SafeArea(
          child: Column(
            mainAxisSize: MainAxisSize.min,
            children: <Widget>[
              ListTile(
                leading: const Icon(Icons.edit),
                title: const Text('Editar'),
                onTap: () {
                  Navigator.pop(context);
                  _navigateToAlarmEdit(context, alarm);
                },
              ),
              ListTile(
                leading: const Icon(Icons.delete),
                title: const Text('Eliminar'),
                onTap: () {
                  Navigator.pop(context);
                  _confirmDeleteAlarm(alarm);
                },
              ),
            ],
          ),
        );
      },
    );
  }

  void _confirmDeleteAlarm(Alarm alarm) {
    showDialog(
      context: context,
      builder: (BuildContext context) {
        return AlertDialog(
          title: const Text('Eliminar Alarma'),
          content: const Text('¿Estás seguro de eliminar esta alarma?'),
          actions: <Widget>[
            TextButton(
              child: const Text('Cancelar'),
              onPressed: () {
                Navigator.of(context).pop();
              },
            ),
            ElevatedButton(
              child: const Text('Eliminar'),
              onPressed: () {
                final alarmService =
                    Provider.of<AlarmService>(context, listen: false);
                alarmService.deleteAlarm(alarm.id);
                Navigator.of(context).pop();
              },
            ),
          ],
        );
      },
    );
  }

  void _toggleAlarm(Alarm alarm) {
    final alarmService = Provider.of<AlarmService>(context, listen: false);
    alarmService.toggleAlarm(alarm.id);
  }

  void _navigateToAlarmEdit(BuildContext context, [Alarm? alarm]) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => AlarmEditScreen(alarm: alarm),
      ),
    );
  }

  void _showIntervalConfigModal() {
    showModalBottomSheet(
      context: context,
      builder: (BuildContext context) {
        return IntervalConfigWidget(
          initialSettings: _intervalSettings,
          onSave: (settings) {
            setState(() {
              _intervalSettings = settings;
            });
            settings.save();
            Navigator.pop(context);
          },
        );
      },
    );
  }
}


--------------------------------------------------

Ruta al script: lib/screens/alarm_ring_screen.dart
Nombre del script: alarm_ring_screen.dart
Contenido del script:
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/alarm.dart';
import '../services/alarm_service.dart';
import '../configuracion/app_settings.dart';
import 'games/math_game_screen.dart';
import 'games/memory_game_screen.dart';

class AlarmRingScreen extends StatefulWidget {
  final Alarm alarm;

  const AlarmRingScreen({
    super.key,
    required this.alarm,
  });

  @override
  State<AlarmRingScreen> createState() => _AlarmRingScreenState();
}

class _AlarmRingScreenState extends State<AlarmRingScreen>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;
  bool _isSnoozing = false;

  @override
  void initState() {
    super.initState();
    _initializeAnimation();
    _requestWakeLock();
    _startVibration();
  }

  void _initializeAnimation() {
    _controller = AnimationController(
      duration: const Duration(seconds: 2),
      vsync: this,
    );

    _animation = Tween<double>(
      begin: 1.0,
      end: 1.2,
    ).animate(CurvedAnimation(
      parent: _controller,
      curve: Curves.easeInOut,
    ));

    _controller.repeat(reverse: true);
  }

  Future<void> _requestWakeLock() async {
    // Implementar wake lock para mantener la pantalla encendida
    // Usar package: wakelock
  }

  void _startVibration() {
    final appSettings = context.read<AppSettings>();
    if (appSettings.vibrationEnabled) {
      // Implementar vibración
      // Usar package: vibration
    }
  }

  void _stopVibration() {
    // Detener vibración
  }

  Future<void> _handleStopAlarm() async {
    if (widget.alarm.requireGame && !_isSnoozing) {
      final gameCompleted = await _showGame();
      if (!gameCompleted) {
        return;
      }
    }

    if (mounted) {
      final alarmService = context.read<AlarmService>();
      await alarmService.stopAlarm(widget.alarm.id);
      if (mounted) {
        Navigator.of(context).pop();
      }
    }
  }

  Future<void> _handleSnooze() async {
    setState(() => _isSnoozing = true);
    
    final alarmService = context.read<AlarmService>();
    await alarmService.snoozeAlarm(widget.alarm.id);
    
    if (mounted) {
      Navigator.of(context).pop();
    }
  }

  Future<bool> _showGame() async {
    if (!mounted) return false;

    final result = await Navigator.push<bool>(
      context,
      MaterialPageRoute(
        builder: (context) {
          if (widget.alarm.selectedGame == 'math') {
            return MathGameScreen(
              difficulty: widget.alarm.gameDifficulty ?? 'easy',
              onGameComplete: () => Navigator.pop(context, true),
              onGameFailed: () => Navigator.pop(context, false),
            );
          } else {
            return MemoryGameScreen(
              difficulty: widget.alarm.gameDifficulty ?? 'easy',
              onGameComplete: () => Navigator.pop(context, true),
              onGameFailed: () => Navigator.pop(context, false),
            );
          }
        },
      ),
    );

    return result ?? false;
  }

  @override
  void dispose() {
    _controller.dispose();
    _stopVibration();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    
    return PopScope(
      canPop: false, // Prevenir el botón de retroceso
      child: Scaffold(
        body: Container(
          decoration: BoxDecoration(
            gradient: LinearGradient(
              begin: Alignment.topCenter,
              end: Alignment.bottomCenter,
              colors: [
                theme.colorScheme.primary,
                theme.colorScheme.primaryContainer,
              ],
            ),
          ),
          child: SafeArea(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.spaceBetween,
              children: [
                // Cabecera con la hora
                Expanded(
                  flex: 3,
                  child: Center(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        AnimatedBuilder(
                          animation: _animation,
                          builder: (context, child) {
                            return Transform.scale(
                              scale: _animation.value,
                              child: Text(
                                _formatTime(widget.alarm.time),
                                style: TextStyle(
                                  fontSize: 72,
                                  fontWeight: FontWeight.bold,
                                  color: theme.colorScheme.onPrimary,
                                ),
                              ),
                            );
                          },
                        ),
                        const SizedBox(height: 16),
                        Text(
                          widget.alarm.name.isEmpty ? 'Alarma' : widget.alarm.name,
                          style: TextStyle(
                            fontSize: 24,
                            color: theme.colorScheme.onPrimary,
                          ),
                        ),
                      ],
                    ),
                  ),
                ),

                // Botones de acción
                Expanded(
                  flex: 2,
                  child: Padding(
                    padding: const EdgeInsets.all(24.0),
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.end,
                      children: [
                        if (widget.alarm.canSnooze() && !_isSnoozing) ...[
                          ElevatedButton(
                            onPressed: _handleSnooze,
                            style: ElevatedButton.styleFrom(
                              backgroundColor: theme.colorScheme.surface,
                              foregroundColor: theme.colorScheme.primary,
                              padding: const EdgeInsets.symmetric(
                                horizontal: 48,
                                vertical: 16,
                              ),
                              shape: RoundedRectangleBorder(
                                borderRadius: BorderRadius.circular(30),
                              ),
                            ),
                            child: Text(
                              'Posponer ${widget.alarm.snoozeTime} minutos',
                              style: const TextStyle(fontSize: 18),
                            ),
                          ),
                          const SizedBox(height: 16),
                        ],
                        ElevatedButton(
                          onPressed: _handleStopAlarm,
                          style: ElevatedButton.styleFrom(
                            backgroundColor: theme.colorScheme.secondary,
                            foregroundColor: theme.colorScheme.onSecondary,
                            padding: const EdgeInsets.symmetric(
                              horizontal: 48,
                              vertical: 16,
                            ),
                            shape: RoundedRectangleBorder(
                              borderRadius: BorderRadius.circular(30),
                            ),
                          ),
                          child: Text(
                            widget.alarm.requireGame
                                ? 'Detener con Juego'
                                : 'Detener',
                            style: const TextStyle(fontSize: 18),
                          ),
                        ),
                      ],
                    ),
                  ),
                ),
              ],
            ),
          ),
        ),
      ),
    );
  }

  String _formatTime(DateTime time) {
    final hours = time.hour.toString().padLeft(2, '0');
    final minutes = time.minute.toString().padLeft(2, '0');
    return '$hours:$minutes';
  }
}

--------------------------------------------------

Ruta al script: lib/screens/day_alarms_screen.dart
Nombre del script: day_alarms_screen.dart
Contenido del script:
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import '../models/alarm.dart';
import '../services/alarm_service.dart';
import '../widgets/alarm_list_item.dart';
import 'alarm_edit_screen.dart';

class DayAlarmsScreen extends StatelessWidget {
  final DateTime selectedDate;
  final String screenTitle;

  const DayAlarmsScreen({
    super.key,
    required this.selectedDate,
    required this.screenTitle,
  });

  @override
  Widget build(BuildContext context) {
    final alarmService = Provider.of<AlarmService>(context);

    return Scaffold(
      appBar: AppBar(
        title: Text(screenTitle),
        actions: [
          // Filtro o acciones adicionales si se requieren
        ],
      ),
      body: RefreshIndicator(
        onRefresh: () async {
          // Método para recargar las alarmas manualmente
          await alarmService.initialize();
        },
        child: StreamBuilder<List<Alarm>>(
          stream: alarmService.alarmsStream,
          initialData: alarmService.alarms,
          builder: (context, snapshot) {
            // Error
            if (snapshot.hasError) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    const Icon(
                      Icons.error_outline,
                      color: Colors.red,
                      size: 60,
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'Error al cargar alarmas',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    Text(snapshot.error.toString()),
                    ElevatedButton(
                      onPressed: () => alarmService.initialize(),
                      child: const Text('Reintentar'),
                    )
                  ],
                ),
              );
            }

            // Sin alarmas para el día
            final dayAlarms = snapshot.data?.where((alarm) {
              return alarm.isEnabled && _isAlarmForDay(alarm, selectedDate);
            }).toList() ?? [];

            if (dayAlarms.isEmpty) {
              return Center(
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Icon(
                      Icons.alarm_off,
                      size: 64,
                      color: Theme.of(context).colorScheme.primary.withOpacity(0.5),
                    ),
                    const SizedBox(height: 16),
                    Text(
                      'No hay alarmas para este día',
                      style: Theme.of(context).textTheme.titleLarge,
                    ),
                    const SizedBox(height: 8),
                    Text(
                      'Crea tu primera alarma para este día',
                      style: Theme.of(context).textTheme.bodyMedium,
                    ),
                  ],
                ),
              );
            }

            // Lista de alarmas para el día
            return ListView.separated(
              itemCount: dayAlarms.length,
              separatorBuilder: (context, index) => const Divider(height: 1),
              itemBuilder: (context, index) {
                final alarm = dayAlarms[index];
                return Dismissible(
                  key: Key(alarm.id),
                  background: Container(
                    color: Colors.red,
                    alignment: Alignment.centerRight,
                    padding: const EdgeInsets.only(right: 20),
                    child: const Icon(
                      Icons.delete,
                      color: Colors.white,
                    ),
                  ),
                  direction: DismissDirection.endToStart,
                  confirmDismiss: (direction) async {
                    // Diálogo de confirmación
                    return await showDialog(
                      context: context,
                      builder: (context) => AlertDialog(
                        title: const Text('Eliminar Alarma'),
                        content: const Text('¿Estás seguro de eliminar esta alarma?'),
                        actions: [
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(false),
                            child: const Text('Cancelar'),
                          ),
                          TextButton(
                            onPressed: () => Navigator.of(context).pop(true),
                            child: const Text('Eliminar'),
                          ),
                        ],
                      ),
                    );
                  },
                  onDismissed: (direction) {
                    alarmService.deleteAlarm(alarm.id);
                  },
                  child: AlarmListItem(
                    alarm: alarm,
                    onTap: () {
                      // Navegación a edición de alarma
                      Navigator.push(
                        context,
                        MaterialPageRoute(
                          builder: (context) => AlarmEditScreen(alarm: alarm),
                        ),
                      );
                    },
                    onToggle: (enabled) {
                      alarmService.toggleAlarm(alarm.id);
                    },
                    onDelete: () {
                      alarmService.deleteAlarm(alarm.id);
                    },
                  ),
                );
              },
            );
          },
        ),
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () {
          // Navegación a creación de nueva alarma
          Navigator.push(
            context,
            MaterialPageRoute(
              builder: (context) => const AlarmEditScreen(),
            ),
          );
        },
        icon: const Icon(Icons.add),
        label: const Text('Nueva Alarma'),
      ),
    );
  }

  bool _isAlarmForDay(Alarm alarm, DateTime targetDate) {
    if (alarm.isOneTime) {
      return _isSameDay(alarm.time, targetDate);
    } else {
      return alarm.weekDays[targetDate.weekday - 1];
    }
  }

  bool _isSameDay(DateTime date1, DateTime date2) {
    return date1.year == date2.year &&
           date1.month == date2.month &&
           date1.day == date2.day;
  }
}

--------------------------------------------------

Ruta al script: lib/screens/game_selection_screen.dart
Nombre del script: game_selection_screen.dart
Contenido del script:
import 'package:flutter/material.dart';

class GameSelectionScreen extends StatefulWidget {
  final String? selectedGame;
  final String? difficulty;

  const GameSelectionScreen({
    super.key,
    this.selectedGame,
    this.difficulty,
  });

  @override
  State<GameSelectionScreen> createState() => _GameSelectionScreenState();
}

class _GameSelectionScreenState extends State<GameSelectionScreen> {
  late String? _selectedGame;
  late String? _selectedDifficulty;

  @override
  void initState() {
    super.initState();
    _selectedGame = widget.selectedGame;
    _selectedDifficulty = widget.difficulty;
  }

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Seleccionar Juego'),
        actions: [
          TextButton(
            onPressed: _canSave()
                ? () => Navigator.pop(context, {
                      'game': _selectedGame,
                      'difficulty': _selectedDifficulty,
                    })
                : null,
            child: const Text('Guardar'),
          ),
        ],
      ),
      body: SingleChildScrollView(
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            const Padding(
              padding: EdgeInsets.all(16.0),
              child: Text(
                'Tipo de Juego',
                style: TextStyle(
                  fontSize: 18,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            _buildGameOptions(),
            if (_selectedGame != null) ...[
              const Padding(
                padding: EdgeInsets.all(16.0),
                child: Text(
                  'Dificultad',
                  style: TextStyle(
                    fontSize: 18,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              _buildDifficultyOptions(),
              const SizedBox(height: 16),
              _buildGamePreview(),
            ],
          ],
        ),
      ),
    );
  }

  Widget _buildGameOptions() {
    return Column(
      children: [
        _buildGameOption(
          'math',
          'Matemáticas',
          'Resuelve operaciones matemáticas',
          Icons.calculate,
        ),
        _buildGameOption(
          'memory',
          'Memoria',
          'Encuentra pares de cartas coincidentes',
          Icons.grid_view,
        ),
      ],
    );
  }

  Widget _buildGameOption(
    String gameId,
    String title,
    String description,
    IconData icon,
  ) {
    final isSelected = _selectedGame == gameId;
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      elevation: isSelected ? 4 : 1,
      color: isSelected ? theme.colorScheme.primaryContainer : null,
      child: InkWell(
        onTap: () {
          setState(() {
            _selectedGame = gameId;
            _selectedDifficulty = null; // Resetear dificultad al cambiar de juego
          });
        },
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Row(
            children: [
              Icon(
                icon,
                size: 32,
                color: isSelected
                    ? theme.colorScheme.onPrimaryContainer
                    : theme.colorScheme.primary,
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: TextStyle(
                        fontSize: 18,
                        fontWeight: FontWeight.bold,
                        color: isSelected
                            ? theme.colorScheme.onPrimaryContainer
                            : null,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      description,
                      style: TextStyle(
                        color: isSelected
                            ? theme.colorScheme.onPrimaryContainer
                            : theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
              if (isSelected)
                Icon(
                  Icons.check_circle,
                  color: theme.colorScheme.primary,
                ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildDifficultyOptions() {
    return Column(
      children: [
        _buildDifficultyOption(
          'easy',
          'Fácil',
          _getDifficultyDescription('easy'),
          Colors.green,
        ),
        _buildDifficultyOption(
          'medium',
          'Media',
          _getDifficultyDescription('medium'),
          Colors.orange,
        ),
        _buildDifficultyOption(
          'hard',
          'Difícil',
          _getDifficultyDescription('hard'),
          Colors.red,
        ),
      ],
    );
  }

  Widget _buildDifficultyOption(
    String difficultyId,
    String title,
    String description,
    Color color,
  ) {
    final isSelected = _selectedDifficulty == difficultyId;
    final theme = Theme.of(context);

    return Card(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      elevation: isSelected ? 4 : 1,
      color: isSelected ? theme.colorScheme.primaryContainer : null,
      child: InkWell(
        onTap: () {
          setState(() {
            _selectedDifficulty = difficultyId;
          });
        },
        child: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Row(
            children: [
              Container(
                width: 24,
                height: 24,
                decoration: BoxDecoration(
                  color: color,
                  shape: BoxShape.circle,
                ),
                child: isSelected
                    ? const Icon(
                        Icons.check,
                        size: 16,
                        color: Colors.white,
                      )
                    : null,
              ),
              const SizedBox(width: 16),
              Expanded(
                child: Column(
                  crossAxisAlignment: CrossAxisAlignment.start,
                  children: [
                    Text(
                      title,
                      style: TextStyle(
                        fontSize: 16,
                        fontWeight: FontWeight.bold,
                        color: isSelected
                            ? theme.colorScheme.onPrimaryContainer
                            : null,
                      ),
                    ),
                    const SizedBox(height: 4),
                    Text(
                      description,
                      style: TextStyle(
                        color: isSelected
                            ? theme.colorScheme.onPrimaryContainer
                            : theme.colorScheme.onSurfaceVariant,
                      ),
                    ),
                  ],
                ),
              ),
            ],
          ),
        ),
      ),
    );
  }

  Widget _buildGamePreview() {
    if (_selectedGame == null || _selectedDifficulty == null) return const SizedBox();

    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          const Text(
            'Vista Previa',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),
          Card(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  Text(_getGamePreviewTitle()),
                  const SizedBox(height: 8),
                  Text(_getGamePreviewDescription()),
                ],
              ),
            ),
          ),
        ],
      ),
    );
  }

  String _getDifficultyDescription(String difficulty) {
    if (_selectedGame == 'math') {
      switch (difficulty) {
        case 'easy':
          return 'Sumas y restas simples (3 problemas)';
        case 'medium':
          return 'Multiplicaciones y divisiones (5 problemas)';
        case 'hard':
          return 'Operaciones combinadas (7 problemas)';
        default:
          return '';
      }
    } else if (_selectedGame == 'memory') {
      switch (difficulty) {
        case 'easy':
          return '6 pares de cartas';
        case 'medium':
          return '12 pares de cartas';
        case 'hard':
          return '18 pares de cartas';
        default:
          return '';
      }
    }
    return '';
  }

  String _getGamePreviewTitle() {
    if (_selectedGame == 'math') {
      return 'Juego de Matemáticas';
    } else {
      return 'Juego de Memoria';
    }
  }

  String _getGamePreviewDescription() {
    return _getDifficultyDescription(_selectedDifficulty!);
  }

  bool _canSave() {
    return _selectedGame != null && _selectedDifficulty != null;
  }
}

--------------------------------------------------

Ruta al script: lib/screens/home_screen.dart
Nombre del script: home_screen.dart
Contenido del script:
import 'package:flutter/material.dart';
import 'package:provider/provider.dart';
import 'package:the_good_alarm/models/alarm_history_entry.dart';
import 'package:the_good_alarm/screens/active_alarms_screen.dart';
import 'package:the_good_alarm/screens/alarm_history_screen.dart';
import 'package:the_good_alarm/screens/day_alarms_screen.dart';
import 'package:the_good_alarm/services/alarm_history_service.dart';
import '../models/alarm.dart';
import '../services/alarm_service.dart';
import '../configuracion/theme_provider.dart';
import '../configuracion/app_settings.dart';
import 'alarm_list_screen.dart';
import 'alarm_edit_screen.dart';

class HomeScreen extends StatefulWidget {
  const HomeScreen({super.key});

  @override
  State<HomeScreen> createState() => _HomeScreenState();
}

class _HomeScreenState extends State<HomeScreen> {
  late ScrollController _scrollController;
  double _titleOpacity = 0.0;
  double _expandedInfoOpacity = 1.0;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController()
      ..addListener(() {
        // Calcular las opacidades basadas en el scroll
        final double expandedHeight =
            200.0; // Altura expandida del SliverAppBar
        final double scrollPosition = _scrollController.offset;
        final double appBarHeight = kToolbarHeight;

        setState(() {
          // Calcular opacidad del título (visible cuando está contraído)
          _titleOpacity = (scrollPosition / (expandedHeight - appBarHeight))
              .clamp(0.0, 1.0);
          // Calcular opacidad de la información expandida
          _expandedInfoOpacity =
              (1 - (scrollPosition / (expandedHeight - appBarHeight)))
                  .clamp(0.0, 1.0);
        });
      });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final alarmService = Provider.of<AlarmService>(context);
    final themeProvider = Provider.of<ThemeProvider>(context);
    final appSettings = Provider.of<AppSettings>(context);

    return Scaffold(
      body: CustomScrollView(
        controller: _scrollController,
        slivers: [
          SliverAppBar(
            expandedHeight: 200.0,
            floating: false,
            pinned: true,
            snap: false,
            title: AnimatedOpacity(
              opacity: _titleOpacity,
              duration: const Duration(milliseconds: 300),
              child: _buildCollapsedTitle(alarmService),
            ),
            flexibleSpace: FlexibleSpaceBar(
              background: AnimatedOpacity(
                opacity: _expandedInfoOpacity,
                duration: const Duration(milliseconds: 300),
                child: Container(
                  decoration: BoxDecoration(
                    gradient: LinearGradient(
                      begin: Alignment.topCenter,
                      end: Alignment.bottomCenter,
                      colors: [
                        Theme.of(context).colorScheme.primary,
                        Theme.of(context).colorScheme.primaryContainer,
                      ],
                    ),
                  ),
                  child: SafeArea(
                    child: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        const SizedBox(
                            height:
                                kToolbarHeight), // Espacio para la barra de título
                        _buildNextAlarmInfo(context, alarmService),
                      ],
                    ),
                  ),
                ),
              ),
            ),
            actions: [
              IconButton(
                icon: Icon(
                  themeProvider.themeMode == ThemeMode.dark
                      ? Icons.light_mode
                      : Icons.dark_mode,
                ),
                onPressed: () {
                  themeProvider.setThemeMode(
                    themeProvider.themeMode == ThemeMode.dark
                        ? ThemeMode.light
                        : ThemeMode.dark,
                  );
                },
              ),
              IconButton(
                icon: const Icon(Icons.settings),
                onPressed: () => _showSettingsDialog(context, appSettings),
              ),
            ],
          ),
          SliverToBoxAdapter(
            child: Padding(
              padding: const EdgeInsets.all(16.0),
              child: Column(
                crossAxisAlignment: CrossAxisAlignment.start,
                children: [
                  _buildQuickActions(context),
                  const SizedBox(height: 24),
                  // Añadir la sección de historial diario
                  Center(
                    child: Text('Historial Diario',
                        style: Theme.of(context).textTheme.titleMedium),
                  ),
                  const SizedBox(height: 8),
                  // Añadir la sección de historial diario')
                  _buildDailyHistory(context),
                ],
              ),
            ),
          ),
        ],
      ),
      floatingActionButton: FloatingActionButton.extended(
        onPressed: () => _createAlarm(context),
        icon: const Icon(Icons.add),
        label: const Text('Nueva Alarma'),
      ),
    );
  }

  Widget _buildCollapsedTitle(AlarmService alarmService) {
    return StreamBuilder<List<Alarm>>(
      stream: alarmService.alarmsStream,
      initialData: alarmService.alarms,
      builder: (context, snapshot) {
        final nextAlarm = _findNextAlarm(snapshot.data ?? []);
        if (nextAlarm == null) {
          return const Text('No hay alarmas');
        }

        return Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(
              _formatTime(nextAlarm.time),
              style: const TextStyle(
                fontSize: 20,
                fontWeight: FontWeight.bold,
              ),
            ),
            const SizedBox(width: 8),
            Text(
              _getTimeUntilAlarm(nextAlarm),
              style: const TextStyle(
                fontSize: 14,
                fontWeight: FontWeight.normal,
              ),
            ),
          ],
        );
      },
    );
  }

  Widget _buildNextAlarmInfo(BuildContext context, AlarmService alarmService) {
    return StreamBuilder<List<Alarm>>(
      stream: alarmService.alarmsStream,
      initialData: alarmService.alarms,
      builder: (context, snapshot) {
        // Manejo de errores
        if (snapshot.hasError) {
          return Text(
            'Error al cargar alarmas',
            style: TextStyle(
              color: Colors.white,
              fontSize: 18,
              backgroundColor: Colors.red,
            ),
          );
        }

        final activeAlarms =
            (snapshot.data ?? []).where((alarm) => alarm.isEnabled).toList();

        if (activeAlarms.isEmpty) {
          return const Text(
            'No hay alarmas activas',
            style: TextStyle(
              color: Colors.white,
              fontSize: 18,
            ),
          );
        }

        final nextAlarm = _findNextAlarm(activeAlarms);
        if (nextAlarm == null) {
          return const Text(
            'No hay alarmas activas',
            style: TextStyle(
              color: Colors.white,
              fontSize: 18,
            ),
          );
        }

        return Column(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [
            Row(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Text(
                  _formatTime(nextAlarm.time),
                  style: const TextStyle(
                    color: Colors.white,
                    fontSize: 48,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(width: 16),
                Switch(
                  value: nextAlarm.isEnabled,
                  onChanged: (bool value) {
                    alarmService.toggleAlarm(nextAlarm.id);
                  },
                  activeColor: Colors.white,
                  inactiveThumbColor: Colors.grey,
                ),
              ],
            ),
            Text(
              _getTimeUntilAlarm(nextAlarm),
              style: const TextStyle(
                color: Colors.white70,
                fontSize: 16,
              ),
            ),
            if (activeAlarms.length > 1)
              TextButton(
                onPressed: () {
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => const ActiveAlarmsScreen(),
                    ),
                  );
                },
                child: const Text(
                  'Ver todas las alarmas activas',
                  style: TextStyle(
                    color: Colors.white,
                  ),
                ),
              ),
          ],
        );
      },
    );
  }

  Widget _buildQuickActions(BuildContext context) {
    return Card(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceAround,
            children: [
              _buildQuickActionButton(
                context,
                'Hoy',
                Icons.today,
                () {
                  final today = DateTime.now();
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => DayAlarmsScreen(
                        selectedDate: today,
                        screenTitle: 'Alarmas de Hoy',
                      ),
                    ),
                  );
                },
              ),
              _buildQuickActionButton(
                context,
                'Mañana',
                Icons.calendar_today,
                () {
                  final tomorrow = DateTime.now().add(const Duration(days: 1));
                  Navigator.push(
                    context,
                    MaterialPageRoute(
                      builder: (context) => DayAlarmsScreen(
                        selectedDate: tomorrow,
                        screenTitle: 'Alarmas de Mañana',
                      ),
                    ),
                  );
                },
              ),
              _buildQuickActionButton(
                context,
                'Todas',
                Icons.list,
                () => Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => const AlarmListScreen(),
                  ),
                ),
              ),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildQuickActionButton(
    BuildContext context,
    String label,
    IconData icon,
    VoidCallback onPressed,
  ) {
    return Column(
      children: [
        IconButton(
          icon: Icon(icon),
          onPressed: onPressed,
          style: IconButton.styleFrom(
            backgroundColor: Theme.of(context).colorScheme.primaryContainer,
            foregroundColor: Theme.of(context).colorScheme.onPrimaryContainer,
          ),
        ),
        const SizedBox(height: 4),
        Text(
          label,
          style: Theme.of(context).textTheme.bodySmall,
          textAlign: TextAlign.center,
        ),
      ],
    );
  }

  Widget _buildUpcomingAlarms(BuildContext context, AlarmService alarmService) {
    return StreamBuilder<List<Alarm>>(
      stream: alarmService.alarmsStream,
      initialData: alarmService.alarms,
      builder: (context, snapshot) {
        // Error
        if (snapshot.hasError) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                const Icon(
                  Icons.error_outline,
                  color: Colors.red,
                  size: 60,
                ),
                const SizedBox(height: 16),
                Text(
                  'Error al cargar alarmas',
                  style: Theme.of(context).textTheme.titleLarge,
                ),
                Text(snapshot.error.toString()),
                ElevatedButton(
                  onPressed: () => alarmService.initialize(),
                  child: const Text('Reintentar'),
                )
              ],
            ),
          );
        }

        // Sin alarmas
        final allAlarms = snapshot.data ?? [];
        final activeAlarms = allAlarms
            .where((alarm) => alarm.isEnabled)
            .toList()
          ..sort(
              (a, b) => a.getNextAlarmTime().compareTo(b.getNextAlarmTime()));

        if (activeAlarms.isEmpty) {
          return Center(
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.alarm_off,
                  size: 64,
                  color: Theme.of(context).colorScheme.primary.withOpacity(0.5),
                ),
                const SizedBox(height: 16),
                Text(
                  'No hay alarmas configuradas',
                  style: Theme.of(context).textTheme.titleLarge?.copyWith(
                        color: Theme.of(context).colorScheme.primary,
                      ),
                ),
                const SizedBox(height: 8),
                Text(
                  'Crea tu primera alarma',
                  style: Theme.of(context).textTheme.bodyMedium,
                ),
              ],
            ),
          );
        }

        return Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          children: [
            Text(
              'Próximas Alarmas',
              style: Theme.of(context).textTheme.titleMedium,
            ),
            const SizedBox(height: 8),
            ListView.builder(
              shrinkWrap: true,
              physics: const NeverScrollableScrollPhysics(),
              itemCount: activeAlarms.take(3).length,
              itemBuilder: (context, index) {
                final alarm = activeAlarms[index];
                return Card(
                  child: ListTile(
                    leading: Column(
                      mainAxisAlignment: MainAxisAlignment.center,
                      children: [
                        Text(
                          _formatTime(alarm.time),
                          style: const TextStyle(
                            fontWeight: FontWeight.bold,
                          ),
                        ),
                      ],
                    ),
                    title: Text(alarm.name.isEmpty ? 'Alarma' : alarm.name),
                    subtitle: Text(_getTimeUntilAlarm(alarm)),
                    trailing: alarm.requireGame
                        ? Icon(
                            _getGameIcon(alarm.selectedGame),
                            color: Theme.of(context).colorScheme.primary,
                          )
                        : null,
                    onTap: () => _editAlarm(context, alarm),
                  ),
                );
              },
            ),
            if (activeAlarms.length > 3) ...[
              const SizedBox(height: 8),
              Center(
                child: TextButton(
                  onPressed: () {
                    Navigator.push(
                      context,
                      MaterialPageRoute(
                        builder: (context) => const AlarmListScreen(),
                      ),
                    );
                  },
                  child: const Text('Ver todas las alarmas'),
                ),
              ),
            ],
          ],
        );
      },
    );
  }

  Alarm? _findNextAlarm(List<Alarm> alarms) {
    if (alarms.isEmpty) return null;

    // Crear una copia mutable de la lista
    final mutableAlarms = List<Alarm>.from(alarms);

    mutableAlarms.sort((a, b) {
      final aNext = a.getNextAlarmTime();
      final bNext = b.getNextAlarmTime();
      return aNext.compareTo(bNext);
    });

    return mutableAlarms.first;
  }

  String _formatTime(DateTime time) {
    final hours = time.hour.toString().padLeft(2, '0');
    final minutes = time.minute.toString().padLeft(2, '0');
    return '$hours:$minutes';
  }

  String _getTimeUntilAlarm(Alarm alarm) {
    final now = DateTime.now();
    final nextAlarmTime = alarm.getNextAlarmTime();
    final difference = nextAlarmTime.difference(now);

    if (difference.inDays > 0) {
      return 'En ${difference.inDays} días';
    } else if (difference.inHours > 0) {
      return 'En ${difference.inHours} horas';
    } else if (difference.inMinutes > 0) {
      return 'En ${difference.inMinutes} minutos';
    } else {
      return 'Muy pronto';
    }
  }

  IconData _getGameIcon(String? gameType) {
    switch (gameType) {
      case 'math':
        return Icons.calculate;
      case 'memory':
        return Icons.grid_view;
      default:
        return Icons.games;
    }
  }

  void _createAlarm(BuildContext context) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => const AlarmEditScreen(),
      ),
    );
  }

  void _editAlarm(BuildContext context, Alarm alarm) {
    Navigator.push(
      context,
      MaterialPageRoute(
        builder: (context) => AlarmEditScreen(alarm: alarm),
      ),
    );
  }

  Future<void> _createQuickAlarm(
      BuildContext context, Duration duration) async {
    final now = DateTime.now();
    final alarmTime = now.add(duration);

    final alarm = Alarm(
      id: DateTime.now().millisecondsSinceEpoch.toString(),
      time: alarmTime,
      isOneTime: true,
    );

    final alarmService = Provider.of<AlarmService>(context, listen: false);
    await alarmService.addAlarm(alarm);

    if (context.mounted) {
      ScaffoldMessenger.of(context).showSnackBar(
        SnackBar(
          content: Text(
            'Alarma creada para ${_formatTime(alarmTime)}',
          ),
          action: SnackBarAction(
            label: 'DESHACER',
            onPressed: () => alarmService.deleteAlarm(alarm.id),
          ),
        ),
      );
    }
  }

  void _showSettingsDialog(BuildContext context, AppSettings settings) {
    showDialog(
      context: context,
      builder: (context) => StatefulBuilder(
        builder: (context, setState) => AlertDialog(
          title: const Text('Configuración'),
          content: Column(
            mainAxisSize: MainAxisSize.min,
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              ListTile(
                title: const Text('Formato de hora'),
                subtitle: Text(
                  settings.timeFormat == TimeFormat.h24
                      ? '24 horas'
                      : '12 horas',
                ),
                trailing: Switch(
                  value: settings.timeFormat == TimeFormat.h24,
                  onChanged: (value) {
                    setState(() {
                      settings.setTimeFormat(
                        value ? TimeFormat.h24 : TimeFormat.h12,
                      );
                    });
                  },
                ),
              ),
              ListTile(
                title: const Text('Método de entrada'),
                subtitle: Text(
                  settings.inputFormat == InputFormat.numpad
                      ? 'Teclado numérico'
                      : 'Selector circular',
                ),
                trailing: Switch(
                  value: settings.inputFormat == InputFormat.numpad,
                  onChanged: (value) {
                    setState(() {
                      settings.setInputFormat(
                        value ? InputFormat.numpad : InputFormat.circular,
                      );
                    });
                  },
                ),
              ),
              ListTile(
                title: const Text('Volumen de alarma'),
                subtitle: Slider(
                  value: settings.alarmVolume,
                  onChanged: (value) {
                    setState(() {
                      settings.setAlarmVolume(value);
                    });
                  },
                  divisions: 10,
                  label: '${(settings.alarmVolume * 100).round()}%',
                ),
              ),
              ListTile(
                title: const Text('Vibración'),
                trailing: Switch(
                  value: settings.vibrationEnabled,
                  onChanged: (value) {
                    setState(() {
                      settings.setVibrationEnabled(value);
                    });
                  },
                ),
              ),
            ],
          ),
          actions: [
            TextButton(
              onPressed: () => Navigator.pop(context),
              child: const Text('Cerrar'),
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildDailyHistory(BuildContext context) {
    final alarmHistoryService = Provider.of<AlarmHistoryService>(context);
    final today = DateTime.now();

    // Filtrar entradas de historial del día de hoy
    final todayEntries = alarmHistoryService.getAllHistory().where((entry) {
      return isSameDay(entry.timestamp, today);
    }).toList();

    if (todayEntries.isEmpty) {
      return const SizedBox.shrink(); // No mostrar nada si no hay historial
    }

    return Card(
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Padding(
            padding: const EdgeInsets.all(16.0),
            child: Text(
              'Historial de Hoy',
              style: Theme.of(context).textTheme.titleMedium,
            ),
          ),
          ListView.builder(
            shrinkWrap: true,
            physics: const NeverScrollableScrollPhysics(),
            itemCount: todayEntries.length,
            itemBuilder: (context, index) {
              final entry = todayEntries[index];
              return ListTile(
                title: Text(_getEventTitle(entry.eventType)),
                subtitle: Text('Alarma: ${entry.alarmId}'),
                trailing: Text(_formatTime(entry.timestamp)),
              );
            },
          ),
          Center(
            child: TextButton(
              onPressed: () {
                Navigator.push(
                  context,
                  MaterialPageRoute(
                    builder: (context) => AlarmHistoryScreen(),
                  ),
                );
              },
              child: const Text('Ver historial completo'),
            ),
          ),
        ],
      ),
    );
  }

  // Método de ayuda para formatear el título del evento
  String _getEventTitle(AlarmEventType eventType) {
    switch (eventType) {
      case AlarmEventType.created:
        return 'Alarma Creada';
      case AlarmEventType.activated:
        return 'Alarma Activada';
      case AlarmEventType.deactivated:
        return 'Alarma Desactivada';
      case AlarmEventType.triggered:
        return 'Alarma Sonó';
      case AlarmEventType.snoozed:
        return 'Alarma Pospuesta';
      case AlarmEventType.stopped:
        return 'Alarma Detenida';
      case AlarmEventType.dismissed:
        return 'Alarma Omitida';
      default:
        return eventType.toString();
    }
  }

  // Método de ayuda para comparar fechas
  bool isSameDay(DateTime date1, DateTime date2) {
    return date1.year == date2.year &&
        date1.month == date2.month &&
        date1.day == date2.day;
  }
}


--------------------------------------------------

Ruta al script: lib/screens/vibration_settings_screen.dart
Nombre del script: vibration_settings_screen.dart
Contenido del script:
import 'package:flutter/material.dart';
import '../services/vibration_service.dart';

class VibrationSettingsScreen extends StatefulWidget {
  const VibrationSettingsScreen({super.key});

  @override
  State<VibrationSettingsScreen> createState() => _VibrationSettingsScreenState();
}

class _VibrationSettingsScreenState extends State<VibrationSettingsScreen> {
  final VibrationService _vibrationService = VibrationService();

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: const Text('Configuración de Vibración'),
      ),
      body: ListView(
        children: [
          SwitchListTile(
            title: const Text('Vibración'),
            subtitle: const Text('Activar o desactivar la vibración'),
            value: _vibrationService.isEnabled,
            onChanged: (value) async {
              await _vibrationService.setEnabled(value);
              setState(() {});
            },
          ),
          if (_vibrationService.isEnabled) ...[
            const Padding(
              padding: EdgeInsets.all(16.0),
              child: Text(
                'Patrones de Vibración',
                style: TextStyle(
                  fontSize: 16,
                  fontWeight: FontWeight.bold,
                ),
              ),
            ),
            ...VibrationService.vibrationPatterns.keys.map(
              (pattern) => _buildPatternTile(pattern),
            ),
          ],
        ],
      ),
    );
  }

  Widget _buildPatternTile(String pattern) {
    final isSelected = _vibrationService.currentPattern == pattern;
    
    return ListTile(
      title: Text(
        pattern.substring(0, 1).toUpperCase() + pattern.substring(1),
      ),
      trailing: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          IconButton(
            icon: const Icon(Icons.play_arrow),
            onPressed: () => _vibrationService.testVibration(pattern),
          ),
          Radio<String>(
            value: pattern,
            groupValue: _vibrationService.currentPattern,
            onChanged: (value) async {
              if (value != null) {
                await _vibrationService.setPattern(value);
                setState(() {});
              }
            },
          ),
        ],
      ),
      selected: isSelected,
      onTap: () async {
        await _vibrationService.setPattern(pattern);
        setState(() {});
      },
    );
  }
}

--------------------------------------------------

Ruta al script: lib/main.dart
Nombre del script: main.dart
Contenido del script:
import 'dart:async';
import 'dart:ui';
import 'package:flutter/material.dart';
import 'package:flutter_local_notifications/flutter_local_notifications.dart';
import 'package:flutter_background_service/flutter_background_service.dart';
import 'package:permission_handler/permission_handler.dart';
import 'package:provider/provider.dart';
import 'package:the_good_alarm/configuracion/app_settings.dart';
import 'package:the_good_alarm/configuracion/theme_provider.dart';
import 'package:the_good_alarm/screens/home_screen.dart';
import 'package:the_good_alarm/services/alarm_history_service.dart';
import 'package:the_good_alarm/services/alarm_service.dart';
import 'package:logging/logging.dart';
import 'package:the_good_alarm/services/notification_service.dart';
import 'package:the_good_alarm/services/permission_service.dart';
import 'package:the_good_alarm/widgets/permission_wrapper.dart';

final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
    FlutterLocalNotificationsPlugin();

final _logger = Logger('MainApp');

void main() async {
  WidgetsFlutterBinding.ensureInitialized();

  // Configurar logging
  Logger.root.level = Level.ALL;
  Logger.root.onRecord.listen((record) {
    debugPrint('${record.level.name}: ${record.time}: ${record.message}');
  });

  // Inicializar notificaciones
  const AndroidInitializationSettings initializationSettingsAndroid =
      AndroidInitializationSettings('@mipmap/ic_launcher');

  const DarwinInitializationSettings initializationSettingsIOS =
      DarwinInitializationSettings(
    requestSoundPermission: false,
    requestBadgePermission: false,
    requestAlertPermission: false,
  );

  const InitializationSettings initializationSettings = InitializationSettings(
    android: initializationSettingsAndroid,
    iOS: initializationSettingsIOS,
  );

  try {
    await flutterLocalNotificationsPlugin.initialize(
      initializationSettings,
      onDidReceiveNotificationResponse: (NotificationResponse details) async {
        // Manejar la respuesta de la notificación
      },
    );
  } catch (e) {
    _logger.severe('Error initializing notifications: $e');
  }

  // Solicitar permisos
  await requestPermissions();

  // Inicializar servicios
  final permissionService = PermissionService();
  await permissionService
      .resetTemporarySkip(); // Resetear el estado temporal al inicio

  final notificationService = NotificationService();
  await notificationService.initialize();

  final alarmService = AlarmService();
  await alarmService.initialize();

  // Iniciar servicio en segundo plano
  await initializeService();

  runApp(const MyApp());
}

Future<void> requestPermissions() async {
  // Solicitar los permisos principales
  await [
    Permission.notification,
    Permission.scheduleExactAlarm,
    Permission.systemAlertWindow,
    Permission.location,
  ].request();
}

Future<void> initializeService() async {
  final service = FlutterBackgroundService();

  // Crear el canal de notificación
  const AndroidNotificationChannel channel = AndroidNotificationChannel(
    'alarm_service', // id
    'Servicio de Alarma', // title
    description: 'Canal para el servicio de alarma en segundo plano',
    importance: Importance.low,
  );

  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();

  // Crear el canal de notificación
  await flutterLocalNotificationsPlugin
      .resolvePlatformSpecificImplementation<
          AndroidFlutterLocalNotificationsPlugin>()
      ?.createNotificationChannel(channel);

  await service.configure(
    androidConfiguration: AndroidConfiguration(
      onStart: onStart,
      autoStart: true,
      isForegroundMode: true,
      notificationChannelId: channel.id,
      initialNotificationTitle: channel.name,
      initialNotificationContent:
          channel.description ?? 'Servicio en ejecución',
      foregroundServiceNotificationId: 888,
    ),
    iosConfiguration: IosConfiguration(
      autoStart: true,
      onBackground: onIosBackground,
      onForeground: onStart,
    ),
  );

  // Iniciar el servicio
  await service.startService();
}

@pragma('vm:entry-point')
void onStart(ServiceInstance service) async {
  // Asegúrate de inicializar correctamente
  WidgetsFlutterBinding.ensureInitialized();
  DartPluginRegistrant.ensureInitialized();

  // Configuración del canal de notificación
  const AndroidNotificationChannel channel = AndroidNotificationChannel(
    'alarm_service',
    'Servicio de Alarma',
    description: 'Canal para el servicio de alarma en segundo plano',
    importance: Importance.low,
  );

  final FlutterLocalNotificationsPlugin flutterLocalNotificationsPlugin =
      FlutterLocalNotificationsPlugin();

  // Configuración de la notificación
  final AndroidNotificationDetails androidPlatformChannelSpecifics =
      AndroidNotificationDetails(
    channel.id,
    channel.name,
    channelDescription: channel.description,
    importance: Importance.low,
    priority: Priority.low,
    ongoing: true,
    autoCancel: false,
  );

  final NotificationDetails platformChannelSpecifics =
      NotificationDetails(android: androidPlatformChannelSpecifics);

  // Mostrar notificación inicial
  await flutterLocalNotificationsPlugin.show(
    888,
    'Servicio de Alarma',
    'La aplicación está ejecutándose en segundo plano',
    platformChannelSpecifics,
  );

  // Manejar actualizaciones
  service.on('update').listen((event) async {
    await flutterLocalNotificationsPlugin.show(
      888,
      'Servicio de Alarma',
      'Ejecutándose en segundo plano',
      platformChannelSpecifics,
    );
  });

  // Timer para mantener el servicio activo
  Timer.periodic(const Duration(minutes: 1), (timer) async {
    // Cambiar la forma de manejar el servicio en primer plano
    if (service is AndroidServiceInstance) {
      // Verificar si el servicio está en primer plano
      if (await service.isForegroundService()) {
        // Mostrar notificación de actualización
        await flutterLocalNotificationsPlugin.show(
          888,
          'Servicio de Alarma',
          'Activo - ${DateTime.now().toString()}',
          platformChannelSpecifics,
        );

        // Enviar datos al canal de Flutter
        service.invoke(
          'update',
          {
            "current_date": DateTime.now().toIso8601String(),
          },
        );
      }
    }
  });

  service.on('stopService').listen((event) {
    service.stopSelf();
  });
}

Future<void> updateNotification(String title, String body) async {
  final androidPlatformChannelSpecifics = AndroidNotificationDetails(
    'alarm_service',
    'Servicio de Alarma',
    channelDescription: 'Notificaciones del servicio de alarma',
    importance: Importance.max,
    priority: Priority.high,
    ongoing: true,
    autoCancel: false,
  );

  final platformChannelSpecifics = NotificationDetails(
    android: androidPlatformChannelSpecifics,
  );

  await flutterLocalNotificationsPlugin.show(
    888,
    title,
    body,
    platformChannelSpecifics,
  );
}

@pragma('vm:entry-point')
Future<bool> onIosBackground(ServiceInstance service) async {
  return true;
}

class MyApp extends StatelessWidget {
  const MyApp({super.key});

  @override
  Widget build(BuildContext context) {
    return MultiProvider(
      providers: [
        ChangeNotifierProvider(create: (_) => ThemeProvider()),
        ChangeNotifierProvider(create: (_) => AppSettings()),
        Provider<AlarmService>(create: (_) => AlarmService()),
        Provider<PermissionService>(create: (_) => PermissionService()),
        Provider<AlarmHistoryService>(
          create: (_) {
            final service = AlarmHistoryService();
            service.initialize(); // Inicializar el servicio
            return service;
          },
        ),
      ],
      child: Consumer<ThemeProvider>(
        builder: (context, themeProvider, child) {
          return MaterialApp(
            title: 'The Good Alarm',
            themeMode: themeProvider.themeMode,
            theme: themeProvider.getLightTheme(),
            darkTheme: themeProvider.getDarkTheme(),
            home: PermissionWrapper(
              child: HomeScreen(), // Tu pantalla principal
            ),
          );
        },
      ),
    );
  }
}


--------------------------------------------------

Ruta al script: lib/widgets/game_widgets/math_problem_widget.dart
Nombre del script: math_problem_widget.dart
Contenido del script:
import 'package:flutter/material.dart';
import '../../screens/games/math_game_screen.dart';

class MathProblemWidget extends StatelessWidget {
  final MathProblem problem;
  final double fontSize;

  const MathProblemWidget({
    super.key,
    required this.problem,
    this.fontSize = 48,
  });

  @override
  Widget build(BuildContext context) {
    return Container(
      padding: const EdgeInsets.all(24),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surfaceContainerHighest,
        borderRadius: BorderRadius.circular(16),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.1),
            blurRadius: 8,
            offset: const Offset(0, 4),
          ),
        ],
      ),
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            problem.num1.toString(),
            style: TextStyle(fontSize: fontSize),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Text(
              _getOperationSymbol(problem.operation),
              style: TextStyle(fontSize: fontSize),
            ),
          ),
          Text(
            problem.num2.toString(),
            style: TextStyle(fontSize: fontSize),
          ),
          Padding(
            padding: const EdgeInsets.symmetric(horizontal: 16),
            child: Text(
              '=',
              style: TextStyle(fontSize: fontSize),
            ),
          ),
          Text(
            '?',
            style: TextStyle(
              fontSize: fontSize,
              fontWeight: FontWeight.bold,
              color: Theme.of(context).colorScheme.primary,
            ),
          ),
        ],
      ),
    );
  }

  String _getOperationSymbol(String operation) {
    switch (operation) {
      case '+':
        return '+';
      case '-':
        return '−';
      case '*':
        return '×';
      case '/':
        return '÷';
      default:
        return operation;
    }
  }
}

--------------------------------------------------

Ruta al script: lib/widgets/game_widgets/memory_card_widget.dart
Nombre del script: memory_card_widget.dart
Contenido del script:
import 'dart:math';

import 'package:flutter/material.dart';
import '../../screens/games/memory_game_screen.dart';

class MemoryCardWidget extends StatefulWidget {
  final MemoryCard card;
  final VoidCallback onTap;

  const MemoryCardWidget({
    super.key,
    required this.card,
    required this.onTap,
  });

  @override
  State<MemoryCardWidget> createState() => _MemoryCardWidgetState();
}

class _MemoryCardWidgetState extends State<MemoryCardWidget>
    with SingleTickerProviderStateMixin {
  late AnimationController _controller;
  late Animation<double> _animation;
  bool _isFrontVisible = false;

  @override
  void initState() {
    super.initState();
    _controller = AnimationController(
      duration: const Duration(milliseconds: 300),
      vsync: this,
    );

    _animation = TweenSequence<double>([
      TweenSequenceItem(
        tween: Tween(begin: 0.0, end: -pi / 2),
        weight: 50.0,
      ),
      TweenSequenceItem(
        tween: Tween(begin: pi / 2, end: 0.0),
        weight: 50.0,
      ),
    ]).animate(_controller);

    _controller.addStatusListener((status) {
      if (status == AnimationStatus.completed) {
        _isFrontVisible = !_isFrontVisible;
        _controller.reset();
      }
    });
  }

  @override
  void didUpdateWidget(MemoryCardWidget oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.card.isFlipped != widget.card.isFlipped) {
      if (widget.card.isFlipped) {
        _showFront();
      } else {
        _showBack();
      }
    }
  }

  void _showFront() {
    setState(() {
      _isFrontVisible = true;
      _controller.forward();
    });
  }

  void _showBack() {
    setState(() {
      _isFrontVisible = false;
      _controller.forward();
    });
  }

  @override
  void dispose() {
    _controller.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: widget.onTap,
      child: AnimatedBuilder(
        animation: _animation,
        builder: (context, child) {
          final transform = Matrix4.identity()
            ..setEntry(3, 2, 0.001)
            ..rotateY(_animation.value);
          return Transform(
            transform: transform,
            alignment: Alignment.center,
            child: _isFrontVisible ? _buildFrontSide() : _buildBackSide(),
          );
        },
      ),
    );
  }

  Widget _buildFrontSide() {
    return Container(
      decoration: BoxDecoration(
        color: widget.card.isMatched
            ? Colors.green.withOpacity(0.3)
            : Theme.of(context).colorScheme.primary,
        borderRadius: BorderRadius.circular(8),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Center(
        child: Text(
          _getCardContent(widget.card.value),
          style: TextStyle(
            color: Theme.of(context).colorScheme.onPrimary,
            fontSize: 24,
            fontWeight: FontWeight.bold,
          ),
        ),
      ),
    );
  }

  Widget _buildBackSide() {
    return Container(
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.surface,
        borderRadius: BorderRadius.circular(8),
        border: Border.all(
          color: Theme.of(context).colorScheme.primary,
          width: 2,
        ),
        boxShadow: [
          BoxShadow(
            color: Colors.black.withOpacity(0.2),
            blurRadius: 4,
            offset: const Offset(0, 2),
          ),
        ],
      ),
      child: Center(
        child: Icon(
          Icons.question_mark,
          size: 32,
          color: Theme.of(context).colorScheme.primary,
        ),
      ),
    );
  }

  String _getCardContent(int value) {
    // Puedes personalizar el contenido de las cartas aquí
    // Por ejemplo, usando emojis, números, letras, etc.
    const List<String> symbols = [
      '🌟', '🎮', '🎵', '🎨', '🚀', '🌈',
      '🦁', '🐘', '🦒', '🦊', '🐼', '🦄',
      '🍎', '🍕', '🍦', '🍪', '🌺', '🎸',
    ];
    return symbols[value % symbols.length];
  }
}

--------------------------------------------------

Ruta al script: lib/widgets/alarm_list_item.dart
Nombre del script: alarm_list_item.dart
Contenido del script:
import 'package:flutter/material.dart';
import '../models/alarm.dart';

class AlarmListItem extends StatelessWidget {
  final Alarm alarm;
  final VoidCallback onTap;
  final Function(bool) onToggle;
  final VoidCallback onDelete;

  const AlarmListItem({
    super.key,
    required this.alarm,
    required this.onTap,
    required this.onToggle,
    required this.onDelete,
  });

  @override
  Widget build(BuildContext context) {
    return Dismissible(
      key: Key(alarm.id),
      direction: DismissDirection.endToStart,
      background: Container(
        alignment: Alignment.centerRight,
        padding: const EdgeInsets.only(right: 20.0),
        color: Colors.red,
        child: const Icon(
          Icons.delete,
          color: Colors.white,
        ),
      ),
      onDismissed: (_) => onDelete(),
      child: ListTile(
        onTap: onTap,
        leading: _buildTimeDisplay(context),
        title: Text(
          alarm.name.isEmpty ? 'Alarma' : alarm.name,
          style: Theme.of(context).textTheme.titleMedium,
        ),
        subtitle: _buildSubtitle(context),
        trailing: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            if (alarm.requireGame)
              Padding(
                padding: const EdgeInsets.only(right: 8.0),
                child: Icon(
                  _getGameIcon(),
                  size: 20,
                  color: Theme.of(context).colorScheme.primary,
                ),
              ),
            Switch(
              value: alarm.isEnabled,
              onChanged: onToggle,
            ),
          ],
        ),
      ),
    );
  }

  Widget _buildTimeDisplay(BuildContext context) {
    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.primaryContainer,
        borderRadius: BorderRadius.circular(8),
      ),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          Text(
            _formatTime(alarm.time),
            style: TextStyle(
              fontSize: 16,
              fontWeight: FontWeight.bold,
              color: Theme.of(context).colorScheme.onPrimaryContainer,
            ),
          ),
        ],
      ),
    );
  }

  Widget _buildSubtitle(BuildContext context) {
    final TextStyle subtitleStyle = Theme.of(context).textTheme.bodySmall!;
    
    if (alarm.isOneTime) {
      return Text(
        'Una vez',
        style: subtitleStyle,
      );
    }

    final List<String> days = ['L', 'M', 'M', 'J', 'V', 'S', 'D'];
    final List<Widget> dayWidgets = [];

    for (int i = 0; i < 7; i++) {
      dayWidgets.add(
        Text(
          days[i],
          style: subtitleStyle.copyWith(
            color: alarm.weekDays[i]
                ? Theme.of(context).colorScheme.primary
                : subtitleStyle.color,
            fontWeight: alarm.weekDays[i] ? FontWeight.bold : FontWeight.normal,
          ),
        ),
      );

      if (i < 6) {
        dayWidgets.add(const Text(' · '));
      }
    }

    return Row(
      children: dayWidgets,
    );
  }

  String _formatTime(DateTime time) {
    return '${time.hour.toString().padLeft(2, '0')}:${time.minute.toString().padLeft(2, '0')}';
  }

  IconData _getGameIcon() {
    if (alarm.selectedGame == 'math') {
      return Icons.calculate;
    } else if (alarm.selectedGame == 'memory') {
      return Icons.grid_view;
    }
    return Icons.games;
  }
}

// Widget de ejemplo para el badge de dificultad
class DifficultyBadge extends StatelessWidget {
  final String difficulty;
  final Color? backgroundColor;
  final Color? textColor;

  const DifficultyBadge({
    super.key,
    required this.difficulty,
    this.backgroundColor,
    this.textColor,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final effectiveBackgroundColor = backgroundColor ?? theme.colorScheme.secondary;
    final effectiveTextColor = textColor ?? theme.colorScheme.onSecondary;

    return Container(
      padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 2),
      decoration: BoxDecoration(
        color: effectiveBackgroundColor,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Text(
        difficulty,
        style: TextStyle(
          color: effectiveTextColor,
          fontSize: 12,
          fontWeight: FontWeight.bold,
        ),
      ),
    );
  }
}


--------------------------------------------------

Ruta al script: lib/widgets/circular_time_picker.dart
Nombre del script: circular_time_picker.dart
Contenido del script:
import 'package:flutter/material.dart';
import 'dart:math' as math;

class CircularTimePicker extends StatefulWidget {
  final TimeOfDay initialTime;
  final void Function(TimeOfDay) onTimeChanged;
  final Color? accentColor;
  final Color? backgroundColor;
  final bool use24HourFormat;

  const CircularTimePicker({
    super.key,
    required this.initialTime,
    required this.onTimeChanged,
    this.accentColor,
    this.backgroundColor,
    this.use24HourFormat = true,
  });

  @override
  State<CircularTimePicker> createState() => _CircularTimePickerState();
}

class _CircularTimePickerState extends State<CircularTimePicker> {
  late TimeOfDay _selectedTime;
  bool _isHourMode = true;

  @override
  void initState() {
    super.initState();
    _selectedTime = widget.initialTime;
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final effectiveAccentColor = widget.accentColor ?? theme.colorScheme.primary;
    final effectiveBackgroundColor = widget.backgroundColor ?? theme.colorScheme.surface;

    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        // Display de la hora seleccionada
        Padding(
          padding: const EdgeInsets.all(24.0),
          child: Row(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              _TimeDisplay(
                value: _formatHour(_selectedTime.hour),
                isSelected: _isHourMode,
                onTap: () => setState(() => _isHourMode = true),
                color: effectiveAccentColor,
              ),
              Text(
                ':',
                style: TextStyle(
                  fontSize: 48,
                  color: effectiveAccentColor,
                ),
              ),
              _TimeDisplay(
                value: _selectedTime.minute.toString().padLeft(2, '0'),
                isSelected: !_isHourMode,
                onTap: () => setState(() => _isHourMode = false),
                color: effectiveAccentColor,
              ),
              if (!widget.use24HourFormat) ...[
                const SizedBox(width: 12),
                _AmPmSwitch(
                  isAm: _selectedTime.hour < 12,
                  onChanged: _handleAmPmChanged,
                  color: effectiveAccentColor,
                ),
              ],
            ],
          ),
        ),
        // Selector circular
        SizedBox(
          height: 300,
          width: 300,
          child: Stack(
            alignment: Alignment.center,
            children: [
              Container(
                decoration: BoxDecoration(
                  shape: BoxShape.circle,
                  color: effectiveBackgroundColor,
                  boxShadow: [
                    BoxShadow(
                      color: Colors.black.withOpacity(0.1),
                      blurRadius: 8,
                      offset: const Offset(0, 4),
                    ),
                  ],
                ),
              ),
              _CircularPicker(
                selectedValue: _isHourMode ? _selectedTime.hour : _selectedTime.minute,
                maxValue: _isHourMode ? (widget.use24HourFormat ? 23 : 11) : 59,
                onValueChanged: (value) {
                  setState(() {
                    if (_isHourMode) {
                      if (!widget.use24HourFormat && _selectedTime.hour >= 12) {
                        value += 12;
                      }
                      _selectedTime = TimeOfDay(hour: value, minute: _selectedTime.minute);
                    } else {
                      _selectedTime = TimeOfDay(hour: _selectedTime.hour, minute: value);
                    }
                    widget.onTimeChanged(_selectedTime);
                  });
                },
                accentColor: effectiveAccentColor,
                isHourMode: _isHourMode,
                use24HourFormat: widget.use24HourFormat,
              ),
            ],
          ),
        ),
      ],
    );
  }

  String _formatHour(int hour) {
    if (widget.use24HourFormat) {
      return hour.toString().padLeft(2, '0');
    }
    final displayHour = hour == 0 ? 12 : (hour > 12 ? hour - 12 : hour);
    return displayHour.toString();
  }

  void _handleAmPmChanged(bool isAm) {
    setState(() {
      final currentHour = _selectedTime.hour;
      final newHour = isAm
          ? (currentHour >= 12 ? currentHour - 12 : currentHour)
          : (currentHour < 12 ? currentHour + 12 : currentHour);
      
      _selectedTime = TimeOfDay(hour: newHour, minute: _selectedTime.minute);
      widget.onTimeChanged(_selectedTime);
    });
  }
}

class _TimeDisplay extends StatelessWidget {
  final String value;
  final bool isSelected;
  final VoidCallback onTap;
  final Color color;

  const _TimeDisplay({
    required this.value,
    required this.isSelected,
    required this.onTap,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 12, vertical: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(8),
          color: isSelected ? color.withOpacity(0.1) : Colors.transparent,
        ),
        child: Text(
          value,
          style: TextStyle(
            fontSize: 48,
            fontWeight: FontWeight.bold,
            color: color,
          ),
        ),
      ),
    );
  }
}

class _AmPmSwitch extends StatelessWidget {
  final bool isAm;
  final ValueChanged<bool> onChanged;
  final Color color;

  const _AmPmSwitch({
    required this.isAm,
    required this.onChanged,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        _AmPmButton(
          text: 'AM',
          isSelected: isAm,
          onTap: () => onChanged(true),
          color: color,
        ),
        const SizedBox(height: 4),
        _AmPmButton(
          text: 'PM',
          isSelected: !isAm,
          onTap: () => onChanged(false),
          color: color,
        ),
      ],
    );
  }
}

class _AmPmButton extends StatelessWidget {
  final String text;
  final bool isSelected;
  final VoidCallback onTap;
  final Color color;

  const _AmPmButton({
    required this.text,
    required this.isSelected,
    required this.onTap,
    required this.color,
  });

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onTap: onTap,
      child: Container(
        padding: const EdgeInsets.symmetric(horizontal: 8, vertical: 4),
        decoration: BoxDecoration(
          borderRadius: BorderRadius.circular(4),
          color: isSelected ? color : Colors.transparent,
        ),
        child: Text(
          text,
          style: TextStyle(
            fontSize: 16,
            fontWeight: FontWeight.bold,
            color: isSelected ? Colors.white : color,
          ),
        ),
      ),
    );
  }
}

class _CircularPicker extends StatefulWidget {
  final int selectedValue;
  final int maxValue;
  final ValueChanged<int> onValueChanged;
  final Color accentColor;
  final bool isHourMode;
  final bool use24HourFormat;

  const _CircularPicker({
    required this.selectedValue,
    required this.maxValue,
    required this.onValueChanged,
    required this.accentColor,
    required this.isHourMode,
    required this.use24HourFormat,
  });

  @override
  State<_CircularPicker> createState() => _CircularPickerState();
}

class _CircularPickerState extends State<_CircularPicker> {
  // ignore: unused_field
  late double _startAngle;
  late double _currentAngle;

  @override
  void initState() {
    super.initState();
    _updateAngle();
  }

  @override
  void didUpdateWidget(_CircularPicker oldWidget) {
    super.didUpdateWidget(oldWidget);
    if (oldWidget.selectedValue != widget.selectedValue) {
      _updateAngle();
    }
  }

  void _updateAngle() {
    _currentAngle = _startAngle = (widget.selectedValue * 360 / (widget.maxValue + 1)) * (math.pi / 180);
  }

  @override
  Widget build(BuildContext context) {
    return GestureDetector(
      onPanStart: _onPanStart,
      onPanUpdate: _onPanUpdate,
      child: CustomPaint(
        size: const Size(300, 300),
        painter: _CircularPickerPainter(
          selectedValue: widget.selectedValue,
          maxValue: widget.maxValue,
          accentColor: widget.accentColor,
          isHourMode: widget.isHourMode,
          use24HourFormat: widget.use24HourFormat,
        ),
      ),
    );
  }

  void _onPanStart(DragStartDetails details) {
    final box = context.findRenderObject() as RenderBox;
    final center = box.size.center(Offset.zero);
    final position = details.localPosition;
    _startAngle = (math.atan2(position.dy - center.dy, position.dx - center.dx) + math.pi * 2) % (math.pi * 2);
  }

  void _onPanUpdate(DragUpdateDetails details) {
    final box = context.findRenderObject() as RenderBox;
    final center = box.size.center(Offset.zero);
    final position = details.localPosition;
    _currentAngle = (math.atan2(position.dy - center.dy, position.dx - center.dx) + math.pi * 2) % (math.pi * 2);

    final anglePercent = _currentAngle / (math.pi * 2);
    final newValue = (anglePercent * (widget.maxValue + 1)).round() % (widget.maxValue + 1);

    if (newValue != widget.selectedValue) {
      widget.onValueChanged(newValue);
    }
  }
}

class _CircularPickerPainter extends CustomPainter {
  final int selectedValue;
  final int maxValue;
  final Color accentColor;
  final bool isHourMode;
  final bool use24HourFormat;

  _CircularPickerPainter({
    required this.selectedValue,
    required this.maxValue,
    required this.accentColor,
    required this.isHourMode,
    required this.use24HourFormat,
  });

  @override
  void paint(Canvas canvas, Size size) {
    final center = Offset(size.width / 2, size.height / 2);
    final radius = size.width / 2;
    
    // Dibujar números
    final textPainter = TextPainter(
      textDirection: TextDirection.ltr,
      textAlign: TextAlign.center,
    );

    for (int i = 0; i <= maxValue; i++) {
      final angle = (i * 360 / (maxValue + 1)) * (math.pi / 180);
      final offset = Offset(
        center.dx + (radius - 30) * math.cos(angle),
        center.dy + (radius - 30) * math.sin(angle),
      );

      String text;
      if (isHourMode) {
        if (use24HourFormat) {
          text = i.toString();
        } else {
          text = (i == 0 ? 12 : i).toString();
        }
      } else {
        text = i.toString().padLeft(2, '0');
      }

      textPainter.text = TextSpan(
        text: text,
        style: TextStyle(
          color: i == selectedValue ? accentColor : Colors.grey,
          fontSize: 16,
          fontWeight: i == selectedValue ? FontWeight.bold : FontWeight.normal,
        ),
      );

      textPainter.layout();
      textPainter.paint(
        canvas,
        offset.translate(-textPainter.width / 2, -textPainter.height / 2),
      );
    }

    // Dibujar indicador
    final paint = Paint()
      ..color = accentColor
      ..style = PaintingStyle.fill;

    final angle = (selectedValue * 360 / (maxValue + 1)) * (math.pi / 180);
    final markerOffset = Offset(
      center.dx + (radius - 30) * math.cos(angle),
      center.dy + (radius - 30) * math.sin(angle),
    );

    canvas.drawCircle(markerOffset, 16, paint);

    // Dibujar línea al centro
    paint.strokeWidth = 2;
    paint.style = PaintingStyle.stroke;
    canvas.drawLine(center, markerOffset, paint);
  }

  @override
  bool shouldRepaint(covariant _CircularPickerPainter oldDelegate) {
    return oldDelegate.selectedValue != selectedValue ||
           oldDelegate.accentColor != accentColor;
  }
}

--------------------------------------------------

Ruta al script: lib/widgets/custom_numpad.dart
Nombre del script: custom_numpad.dart
Contenido del script:
import 'package:flutter/material.dart';

class CustomNumpad extends StatelessWidget {
  final Function(String) onNumberTap;
  final VoidCallback onDeleteTap;
  final VoidCallback onDoneTap;
  final bool showDoneButton;
  final String? doneButtonText;
  final Color? numberColor;
  final Color? iconColor;
  final Color? doneButtonColor;

  const CustomNumpad({
    super.key,
    required this.onNumberTap,
    required this.onDeleteTap,
    required this.onDoneTap,
    this.showDoneButton = true,
    this.doneButtonText,
    this.numberColor,
    this.iconColor,
    this.doneButtonColor,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);
    final effectiveNumberColor = numberColor ?? theme.colorScheme.primary;
    final effectiveIconColor = iconColor ?? theme.colorScheme.primary;
    final effectiveDoneButtonColor = doneButtonColor ?? theme.colorScheme.primary;

    return Container(
      padding: const EdgeInsets.all(16),
      child: Column(
        mainAxisAlignment: MainAxisAlignment.center,
        children: [
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _buildNumberButton('1', effectiveNumberColor),
              _buildNumberButton('2', effectiveNumberColor),
              _buildNumberButton('3', effectiveNumberColor),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _buildNumberButton('4', effectiveNumberColor),
              _buildNumberButton('5', effectiveNumberColor),
              _buildNumberButton('6', effectiveNumberColor),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _buildNumberButton('7', effectiveNumberColor),
              _buildNumberButton('8', effectiveNumberColor),
              _buildNumberButton('9', effectiveNumberColor),
            ],
          ),
          const SizedBox(height: 16),
          Row(
            mainAxisAlignment: MainAxisAlignment.spaceEvenly,
            children: [
              _buildSpecialButton(
                icon: Icons.backspace,
                onTap: onDeleteTap,
                color: effectiveIconColor,
              ),
              _buildNumberButton('0', effectiveNumberColor),
              if (showDoneButton)
                _buildSpecialButton(
                  icon: Icons.check,
                  onTap: onDoneTap,
                  color: effectiveDoneButtonColor,
                  text: doneButtonText,
                )
              else
                const SizedBox(width: 70),
            ],
          ),
        ],
      ),
    );
  }

  Widget _buildNumberButton(String number, Color color) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: () => onNumberTap(number),
        borderRadius: BorderRadius.circular(40),
        child: Container(
          width: 70,
          height: 70,
          alignment: Alignment.center,
          child: Text(
            number,
            style: TextStyle(
              fontSize: 32,
              color: color,
              fontWeight: FontWeight.bold,
            ),
          ),
        ),
      ),
    );
  }

  Widget _buildSpecialButton({
    required IconData icon,
    required VoidCallback onTap,
    required Color color,
    String? text,
  }) {
    return Material(
      color: Colors.transparent,
      child: InkWell(
        onTap: onTap,
        borderRadius: BorderRadius.circular(40),
        child: Container(
          width: 70,
          height: 70,
          alignment: Alignment.center,
          child: text != null
              ? Text(
                  text,
                  style: TextStyle(
                    fontSize: 18,
                    color: color,
                    fontWeight: FontWeight.bold,
                  ),
                )
              : Icon(
                  icon,
                  color: color,
                  size: 28,
                ),
        ),
      ),
    );
  }
}

// Widget de ejemplo para mostrar cómo se usa el CustomNumpad
class TimeInputWithNumpad extends StatefulWidget {
  final void Function(TimeOfDay) onTimeSelected;

  const TimeInputWithNumpad({
    super.key,
    required this.onTimeSelected,
  });

  @override
  State<TimeInputWithNumpad> createState() => _TimeInputWithNumpadState();
}

class _TimeInputWithNumpadState extends State<TimeInputWithNumpad> {
  String _input = '';

  void _handleNumberInput(String number) {
    if (_input.length < 4) {
      setState(() {
        _input += number;
      });
    }
  }

  void _handleDelete() {
    if (_input.isNotEmpty) {
      setState(() {
        _input = _input.substring(0, _input.length - 1);
      });
    }
  }

  void _handleDone() {
    if (_input.length == 4) {
      final hours = int.parse(_input.substring(0, 2));
      final minutes = int.parse(_input.substring(2, 4));
      
      if (hours < 24 && minutes < 60) {
        widget.onTimeSelected(TimeOfDay(hour: hours, minute: minutes));
      } else {
        // Mostrar error
        ScaffoldMessenger.of(context).showSnackBar(
          const SnackBar(
            content: Text('Hora inválida. Use formato 24h (0000-2359)'),
          ),
        );
      }
    }
  }

  String get formattedTime {
    if (_input.isEmpty) return '--:--';
    
    final paddedInput = _input.padRight(4, '-');
    return '${paddedInput.substring(0, 2)}:${paddedInput.substring(2)}';
  }

  @override
  Widget build(BuildContext context) {
    return Column(
      mainAxisSize: MainAxisSize.min,
      children: [
        Padding(
          padding: const EdgeInsets.all(24.0),
          child: Text(
            formattedTime,
            style: Theme.of(context).textTheme.displayMedium,
          ),
        ),
        CustomNumpad(
          onNumberTap: _handleNumberInput,
          onDeleteTap: _handleDelete,
          onDoneTap: _handleDone,
        ),
      ],
    );
  }
}

--------------------------------------------------

Ruta al script: lib/widgets/intervalos.dart
Nombre del script: intervalos.dart
Contenido del script:

import 'package:flutter/material.dart';
import 'package:the_good_alarm/models/time_interval_settings.dart';

class IntervalConfigWidget extends StatefulWidget {
  final TimeIntervalSettings initialSettings;
  final Function(TimeIntervalSettings) onSave;

  const IntervalConfigWidget({
    super.key,
    required this.initialSettings,
    required this.onSave,
  });

  @override
  State<IntervalConfigWidget> createState() => _IntervalConfigWidgetState();
}

class _IntervalConfigWidgetState extends State<IntervalConfigWidget> {
  late TimeOfDay _morningStart;
  late TimeOfDay _morningEnd;
  late TimeOfDay _afternoonStart;
  late TimeOfDay _afternoonEnd;
  late TimeOfDay _nightStart;
  late TimeOfDay _nightEnd;

  @override
  void initState() {
    super.initState();
    _morningStart = widget.initialSettings.morningStart;
    _morningEnd = widget.initialSettings.morningEnd;
    _afternoonStart = widget.initialSettings.afternoonStart;
    _afternoonEnd = widget.initialSettings.afternoonEnd;
    _nightStart = widget.initialSettings.nightStart;
    _nightEnd = widget.initialSettings.nightEnd;
  }

  Future<void> _pickTime(
      TimeOfDay initialTime, void Function(TimeOfDay) onPicked) async {
    final pickedTime = await showTimePicker(
      context: context,
      initialTime: initialTime,
    );
    if (pickedTime != null) {
      setState(() {
        onPicked(pickedTime);
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    return Padding(
      padding: const EdgeInsets.all(16.0),
      child: Column(
        mainAxisSize: MainAxisSize.min,
        children: [
          const Text(
            'Configurar Intervalos de Tiempo',
            style: TextStyle(
              fontSize: 18,
              fontWeight: FontWeight.bold,
            ),
          ),
          const SizedBox(height: 16),
          _buildIntervalRow('Mañana', _morningStart, _morningEnd,
              (start) => _morningStart = start, (end) => _morningEnd = end),
          _buildIntervalRow('Tarde', _afternoonStart, _afternoonEnd,
              (start) => _afternoonStart = start, (end) => _afternoonEnd = end),
          _buildIntervalRow('Noche', _nightStart, _nightEnd,
              (start) => _nightStart = start, (end) => _nightEnd = end),
          const SizedBox(height: 16),
          ElevatedButton(
            onPressed: _saveSettings,
            child: const Text('Guardar'),
          ),
        ],
      ),
    );
  }

  Widget _buildIntervalRow(
    String title,
    TimeOfDay start,
    TimeOfDay end,
    void Function(TimeOfDay) onStartChanged,
    void Function(TimeOfDay) onEndChanged,
  ) {
    return Padding(
      padding: const EdgeInsets.symmetric(vertical: 8.0),
      child: Row(
        children: [
          Text(title),
          const SizedBox(width: 16),
          ElevatedButton(
            onPressed: () => _pickTime(start, onStartChanged),
            child: Text(
                '${start.hour.toString().padLeft(2, '0')}:${start.minute.toString().padLeft(2, '0')}'),
          ),
          const SizedBox(width: 8),
          const Text('a'),
          const SizedBox(width: 8),
          ElevatedButton(
            onPressed: () => _pickTime(end, onEndChanged),
            child: Text(
                '${end.hour.toString().padLeft(2, '0')}:${end.minute.toString().padLeft(2, '0')}'),
          ),
        ],
      ),
    );
  }

  void _saveSettings() {
    final newSettings = TimeIntervalSettings(
      morningStart: _morningStart,
      morningEnd: _morningEnd,
      afternoonStart: _afternoonStart,
      afternoonEnd: _afternoonEnd,
      nightStart: _nightStart,
      nightEnd: _nightEnd,
    );

    if (newSettings.isValidConfiguration()) {
      widget.onSave(newSettings);
    } else {
      ScaffoldMessenger.of(context).showSnackBar(
        const SnackBar(content: Text('Configuración de intervalos no válida')),
      );
    }
  }
}


--------------------------------------------------

Ruta al script: lib/widgets/permission_wrapper.dart
Nombre del script: permission_wrapper.dart
Contenido del script:
import 'package:flutter/material.dart';
import '../services/permission_service.dart';

class PermissionWrapper extends StatefulWidget {
  final Widget child;

  const PermissionWrapper({
    super.key,
    required this.child,
  });

  @override
  State<PermissionWrapper> createState() => _PermissionWrapperState();
}

class _PermissionWrapperState extends State<PermissionWrapper> {
  final PermissionService _permissionService = PermissionService();
  bool _checkingPermissions = true;

  @override
  void initState() {
    super.initState();
    _checkPermissions();
  }

  Future<void> _checkPermissions() async {
    await _permissionService.checkInitialPermissions();
    if (!_permissionService.areAllCriticalPermissionsGranted && mounted) {
      await _permissionService.requestRequiredPermissions(context);
    }
    if (mounted) {
      setState(() {
        _checkingPermissions = false;
      });
    }
  }

  @override
  Widget build(BuildContext context) {
    if (_checkingPermissions) {
      return const Scaffold(
        body: Center(
          child: CircularProgressIndicator(),
        ),
      );
    }

    if (!_permissionService.areAllCriticalPermissionsGranted) {
      return Scaffold(
        body: Center(
          child: Padding(
            padding: const EdgeInsets.all(24.0),
            child: Column(
              mainAxisAlignment: MainAxisAlignment.center,
              children: [
                Icon(
                  Icons.warning_amber_rounded,
                  size: 64,
                  color: Theme.of(context).colorScheme.error,
                ),
                const SizedBox(height: 16),
                const Text(
                  'Permisos Necesarios',
                  style: TextStyle(
                    fontSize: 24,
                    fontWeight: FontWeight.bold,
                  ),
                ),
                const SizedBox(height: 16),
                const Text(
                  'Para usar las alarmas, necesitamos algunos permisos básicos.',
                  textAlign: TextAlign.center,
                ),
                const SizedBox(height: 24),
                Row(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    TextButton(
                      onPressed: () async {
                        await _permissionService.temporarilySkipPermissions();
                        if (mounted) {
                          setState(() {});
                        }
                      },
                      child: const Text('Más tarde'),
                    ),
                    const SizedBox(width: 16),
                    ElevatedButton(
                      onPressed: () async {
                        await _permissionService.requestRequiredPermissions(context);
                        if (mounted) {
                          setState(() {});
                        }
                      },
                      child: const Text('Conceder Permisos'),
                    ),
                  ],
                ),
              ],
            ),
          ),
        ),
      );
    }

    return widget.child;
  }
}

--------------------------------------------------

